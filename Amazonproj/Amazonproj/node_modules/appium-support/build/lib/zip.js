"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAllTo = extractAllTo;
exports.readEntries = readEntries;
exports.toInMemoryZip = toInMemoryZip;
exports._extractEntryTo = _extractEntryTo;
exports.assertValidZip = assertValidZip;
exports.toArchive = toArchive;
exports.default = void 0;

require("source-map-support/register");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _extractZip = _interopRequireDefault(require("extract-zip"));

var _yauzl = _interopRequireDefault(require("yauzl"));

var _archiver = _interopRequireDefault(require("archiver"));

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _mkdirp = require("../lib/mkdirp");

var _stream = _interopRequireDefault(require("stream"));

var _fs2 = _interopRequireDefault(require("./fs"));

var _base64Stream = require("base64-stream");

var _util = require("./util");

var _timing = _interopRequireDefault(require("./timing"));

var _logger = _interopRequireDefault(require("./logger"));

const extract = _bluebird.default.promisify(_extractZip.default);

const open = _bluebird.default.promisify(_yauzl.default.open);

const ZIP_MAGIC = 'PK';

async function extractAllTo(zipFilePath, destDir) {
  return await extract(zipFilePath, {
    dir: destDir
  });
}

async function _extractEntryTo(zipFile, entry, destDir) {
  const dstPath = _path.default.resolve(destDir, entry.fileName);

  if (/\/$/.test(entry.fileName)) {
    if (!(await _fs2.default.exists(dstPath))) {
      await (0, _mkdirp.mkdirp)(dstPath);
    }

    return;
  } else if (!(await _fs2.default.exists(_path.default.dirname(dstPath)))) {
    await (0, _mkdirp.mkdirp)(_path.default.dirname(dstPath));
  }

  const writeStream = (0, _fs.createWriteStream)(dstPath, {
    flags: 'w'
  });
  const writeStreamPromise = new _bluebird.default((resolve, reject) => {
    writeStream.once('finish', resolve);
    writeStream.once('error', reject);
  });
  const zipReadStream = await new _bluebird.default((resolve, reject) => {
    zipFile.openReadStream(entry, (err, readStream) => err ? reject(err) : resolve(readStream));
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipReadStream.once('end', resolve);
    zipReadStream.once('error', reject);
  });
  zipReadStream.pipe(writeStream);
  return await _bluebird.default.all([zipReadStreamPromise, writeStreamPromise]);
}

async function readEntries(zipFilePath, onEntry) {
  const zipfile = await open(zipFilePath, {
    lazyEntries: true
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipfile.once('end', resolve);
    zipfile.once('error', reject);
    zipfile.on('entry', async entry => {
      const res = await onEntry({
        entry,
        extractEntryTo: async destDir => await _extractEntryTo(zipfile, entry, destDir)
      });

      if (res === false) {
        return zipfile.emit('end');
      }

      zipfile.readEntry();
    });
  });
  zipfile.readEntry();
  return await zipReadStreamPromise;
}

async function toInMemoryZip(srcPath, opts = {}) {
  if (!(await _fs2.default.exists(srcPath))) {
    throw new Error(`No such file or folder: ${srcPath}`);
  }

  const {
    isMetered = true,
    encodeToBase64 = false,
    maxSize = 1 * _util.GiB,
    level = 9
  } = opts;
  const resultBuffers = [];
  let resultBuffersSize = 0;
  const resultWriteStream = new _stream.default.Writable({
    write: (buffer, encoding, next) => {
      resultBuffers.push(buffer);
      resultBuffersSize += buffer.length;

      if (maxSize > 0 && resultBuffersSize > maxSize) {
        resultWriteStream.emit('error', new Error(`The size of the resulting ` + `archive must not be greater than ${(0, _util.toReadableSizeString)(maxSize)}`));
      }

      next();
    }
  });
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });
  let srcSize = null;
  const base64EncoderStream = encodeToBase64 ? new _base64Stream.Base64Encode() : null;
  const resultWriteStreamPromise = new _bluebird.default((resolve, reject) => {
    resultWriteStream.once('error', e => {
      if (base64EncoderStream) {
        archive.unpipe(base64EncoderStream);
        base64EncoderStream.unpipe(resultWriteStream);
      } else {
        archive.unpipe(resultWriteStream);
      }

      archive.abort();
      archive.destroy();
      reject(e);
    });
    resultWriteStream.once('finish', () => {
      srcSize = archive.pointer();
      resolve();
    });
  });
  const archiveStreamPromise = new _bluebird.default((resolve, reject) => {
    archive.once('finish', resolve);
    archive.once('error', e => reject(new Error(`Failed to archive '${srcPath}': ${e.message}`)));
  });
  const timer = isMetered ? new _timing.default().start() : null;

  if ((await _fs2.default.stat(srcPath)).isDirectory()) {
    archive.directory(srcPath, false);
  } else {
    archive.file(srcPath, {
      name: _path.default.basename(srcPath)
    });
  }

  if (base64EncoderStream) {
    archive.pipe(base64EncoderStream);
    base64EncoderStream.pipe(resultWriteStream);
  } else {
    archive.pipe(resultWriteStream);
  }

  archive.finalize();
  await _bluebird.default.all([archiveStreamPromise, resultWriteStreamPromise]);

  if (timer) {
    _logger.default.debug(`Zipped ${encodeToBase64 ? 'and base64-encoded ' : ''}` + `'${_path.default.basename(srcPath)}' ` + (srcSize ? `(${(0, _util.toReadableSizeString)(srcSize)}) ` : '') + `in ${timer.getDuration().asSeconds.toFixed(3)}s ` + `(compression level: ${level})`);
  }

  return Buffer.concat(resultBuffers);
}

async function assertValidZip(filePath) {
  if (!(await _fs2.default.exists(filePath))) {
    throw new Error(`The file at '${filePath}' does not exist`);
  }

  const {
    size
  } = await _fs2.default.stat(filePath);

  if (size < 4) {
    throw new Error(`The file at '${filePath}' is too small to be a ZIP archive`);
  }

  const fd = await _fs2.default.open(filePath, 'r');

  try {
    const buffer = Buffer.alloc(ZIP_MAGIC.length);
    await _fs2.default.read(fd, buffer, 0, ZIP_MAGIC.length, 0);
    const signature = buffer.toString('ascii');

    if (signature !== ZIP_MAGIC) {
      throw new Error(`The file signature '${signature}' of '${filePath}' ` + `is not equal to the expected ZIP archive signature '${ZIP_MAGIC}'`);
    }

    return true;
  } finally {
    await _fs2.default.close(fd);
  }
}

async function toArchive(dstPath, src = {}, opts = {}) {
  const {
    level = 9
  } = opts;
  const {
    pattern = '**/*',
    cwd = _path.default.dirname(dstPath),
    ignore = []
  } = src;
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });

  const stream = _fs2.default.createWriteStream(dstPath);

  return await new _bluebird.default((resolve, reject) => {
    archive.glob(pattern, {
      cwd,
      ignore
    }).on('error', reject).pipe(stream);
    stream.on('error', e => {
      archive.unpipe(stream);
      archive.abort();
      archive.destroy();
      reject(e);
    }).on('finish', resolve);
    archive.finalize();
  });
}

var _default = {
  extractAllTo,
  readEntries,
  toInMemoryZip,
  assertValidZip,
  toArchive
};
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi96aXAuanMiXSwibmFtZXMiOlsiZXh0cmFjdCIsIkIiLCJwcm9taXNpZnkiLCJub2RlRXh0cmFjdCIsIm9wZW4iLCJ5YXV6bCIsIlpJUF9NQUdJQyIsImV4dHJhY3RBbGxUbyIsInppcEZpbGVQYXRoIiwiZGVzdERpciIsImRpciIsIl9leHRyYWN0RW50cnlUbyIsInppcEZpbGUiLCJlbnRyeSIsImRzdFBhdGgiLCJwYXRoIiwicmVzb2x2ZSIsImZpbGVOYW1lIiwidGVzdCIsImZzIiwiZXhpc3RzIiwiZGlybmFtZSIsIndyaXRlU3RyZWFtIiwiZmxhZ3MiLCJ3cml0ZVN0cmVhbVByb21pc2UiLCJyZWplY3QiLCJvbmNlIiwiemlwUmVhZFN0cmVhbSIsIm9wZW5SZWFkU3RyZWFtIiwiZXJyIiwicmVhZFN0cmVhbSIsInppcFJlYWRTdHJlYW1Qcm9taXNlIiwicGlwZSIsImFsbCIsInJlYWRFbnRyaWVzIiwib25FbnRyeSIsInppcGZpbGUiLCJsYXp5RW50cmllcyIsIm9uIiwicmVzIiwiZXh0cmFjdEVudHJ5VG8iLCJlbWl0IiwicmVhZEVudHJ5IiwidG9Jbk1lbW9yeVppcCIsInNyY1BhdGgiLCJvcHRzIiwiRXJyb3IiLCJpc01ldGVyZWQiLCJlbmNvZGVUb0Jhc2U2NCIsIm1heFNpemUiLCJHaUIiLCJsZXZlbCIsInJlc3VsdEJ1ZmZlcnMiLCJyZXN1bHRCdWZmZXJzU2l6ZSIsInJlc3VsdFdyaXRlU3RyZWFtIiwic3RyZWFtIiwiV3JpdGFibGUiLCJ3cml0ZSIsImJ1ZmZlciIsImVuY29kaW5nIiwibmV4dCIsInB1c2giLCJsZW5ndGgiLCJhcmNoaXZlIiwiemxpYiIsInNyY1NpemUiLCJiYXNlNjRFbmNvZGVyU3RyZWFtIiwiQmFzZTY0RW5jb2RlIiwicmVzdWx0V3JpdGVTdHJlYW1Qcm9taXNlIiwiZSIsInVucGlwZSIsImFib3J0IiwiZGVzdHJveSIsInBvaW50ZXIiLCJhcmNoaXZlU3RyZWFtUHJvbWlzZSIsIm1lc3NhZ2UiLCJ0aW1lciIsIlRpbWVyIiwic3RhcnQiLCJzdGF0IiwiaXNEaXJlY3RvcnkiLCJkaXJlY3RvcnkiLCJmaWxlIiwibmFtZSIsImJhc2VuYW1lIiwiZmluYWxpemUiLCJsb2ciLCJkZWJ1ZyIsImdldER1cmF0aW9uIiwiYXNTZWNvbmRzIiwidG9GaXhlZCIsIkJ1ZmZlciIsImNvbmNhdCIsImFzc2VydFZhbGlkWmlwIiwiZmlsZVBhdGgiLCJzaXplIiwiZmQiLCJhbGxvYyIsInJlYWQiLCJzaWduYXR1cmUiLCJ0b1N0cmluZyIsImNsb3NlIiwidG9BcmNoaXZlIiwic3JjIiwicGF0dGVybiIsImN3ZCIsImlnbm9yZSIsImNyZWF0ZVdyaXRlU3RyZWFtIiwiZ2xvYiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNQSxPQUFPLEdBQUdDLGtCQUFFQyxTQUFGLENBQVlDLG1CQUFaLENBQWhCOztBQUNBLE1BQU1DLElBQUksR0FBR0gsa0JBQUVDLFNBQUYsQ0FBWUcsZUFBTUQsSUFBbEIsQ0FBYjs7QUFDQSxNQUFNRSxTQUFTLEdBQUcsSUFBbEI7O0FBUUEsZUFBZUMsWUFBZixDQUE2QkMsV0FBN0IsRUFBMENDLE9BQTFDLEVBQW1EO0FBQ2pELFNBQU8sTUFBTVQsT0FBTyxDQUFDUSxXQUFELEVBQWM7QUFBQ0UsSUFBQUEsR0FBRyxFQUFFRDtBQUFOLEdBQWQsQ0FBcEI7QUFDRDs7QUFTRCxlQUFlRSxlQUFmLENBQWdDQyxPQUFoQyxFQUF5Q0MsS0FBekMsRUFBZ0RKLE9BQWhELEVBQXlEO0FBQ3ZELFFBQU1LLE9BQU8sR0FBR0MsY0FBS0MsT0FBTCxDQUFhUCxPQUFiLEVBQXNCSSxLQUFLLENBQUNJLFFBQTVCLENBQWhCOztBQUdBLE1BQUksTUFBTUMsSUFBTixDQUFXTCxLQUFLLENBQUNJLFFBQWpCLENBQUosRUFBZ0M7QUFDOUIsUUFBSSxFQUFDLE1BQU1FLGFBQUdDLE1BQUgsQ0FBVU4sT0FBVixDQUFQLENBQUosRUFBK0I7QUFDN0IsWUFBTSxvQkFBT0EsT0FBUCxDQUFOO0FBQ0Q7O0FBQ0Q7QUFDRCxHQUxELE1BS08sSUFBSSxFQUFDLE1BQU1LLGFBQUdDLE1BQUgsQ0FBVUwsY0FBS00sT0FBTCxDQUFhUCxPQUFiLENBQVYsQ0FBUCxDQUFKLEVBQTZDO0FBQ2xELFVBQU0sb0JBQU9DLGNBQUtNLE9BQUwsQ0FBYVAsT0FBYixDQUFQLENBQU47QUFDRDs7QUFHRCxRQUFNUSxXQUFXLEdBQUcsMkJBQWtCUixPQUFsQixFQUEyQjtBQUFDUyxJQUFBQSxLQUFLLEVBQUU7QUFBUixHQUEzQixDQUFwQjtBQUNBLFFBQU1DLGtCQUFrQixHQUFHLElBQUl2QixpQkFBSixDQUFNLENBQUNlLE9BQUQsRUFBVVMsTUFBVixLQUFxQjtBQUNwREgsSUFBQUEsV0FBVyxDQUFDSSxJQUFaLENBQWlCLFFBQWpCLEVBQTJCVixPQUEzQjtBQUNBTSxJQUFBQSxXQUFXLENBQUNJLElBQVosQ0FBaUIsT0FBakIsRUFBMEJELE1BQTFCO0FBQ0QsR0FIMEIsQ0FBM0I7QUFPQSxRQUFNRSxhQUFhLEdBQUcsTUFBTSxJQUFJMUIsaUJBQUosQ0FBTSxDQUFDZSxPQUFELEVBQVVTLE1BQVYsS0FBcUI7QUFDckRiLElBQUFBLE9BQU8sQ0FBQ2dCLGNBQVIsQ0FBdUJmLEtBQXZCLEVBQThCLENBQUNnQixHQUFELEVBQU1DLFVBQU4sS0FBcUJELEdBQUcsR0FBR0osTUFBTSxDQUFDSSxHQUFELENBQVQsR0FBaUJiLE9BQU8sQ0FBQ2MsVUFBRCxDQUE5RTtBQUNELEdBRjJCLENBQTVCO0FBR0EsUUFBTUMsb0JBQW9CLEdBQUcsSUFBSTlCLGlCQUFKLENBQU0sQ0FBQ2UsT0FBRCxFQUFVUyxNQUFWLEtBQXFCO0FBQ3RERSxJQUFBQSxhQUFhLENBQUNELElBQWQsQ0FBbUIsS0FBbkIsRUFBMEJWLE9BQTFCO0FBQ0FXLElBQUFBLGFBQWEsQ0FBQ0QsSUFBZCxDQUFtQixPQUFuQixFQUE0QkQsTUFBNUI7QUFDRCxHQUg0QixDQUE3QjtBQUlBRSxFQUFBQSxhQUFhLENBQUNLLElBQWQsQ0FBbUJWLFdBQW5CO0FBR0EsU0FBTyxNQUFNckIsa0JBQUVnQyxHQUFGLENBQU0sQ0FDakJGLG9CQURpQixFQUVqQlAsa0JBRmlCLENBQU4sQ0FBYjtBQUlEOztBQWtCRCxlQUFlVSxXQUFmLENBQTRCMUIsV0FBNUIsRUFBeUMyQixPQUF6QyxFQUFrRDtBQUVoRCxRQUFNQyxPQUFPLEdBQUcsTUFBTWhDLElBQUksQ0FBQ0ksV0FBRCxFQUFjO0FBQUM2QixJQUFBQSxXQUFXLEVBQUU7QUFBZCxHQUFkLENBQTFCO0FBQ0EsUUFBTU4sb0JBQW9CLEdBQUcsSUFBSTlCLGlCQUFKLENBQU0sQ0FBQ2UsT0FBRCxFQUFVUyxNQUFWLEtBQXFCO0FBQ3REVyxJQUFBQSxPQUFPLENBQUNWLElBQVIsQ0FBYSxLQUFiLEVBQW9CVixPQUFwQjtBQUNBb0IsSUFBQUEsT0FBTyxDQUFDVixJQUFSLENBQWEsT0FBYixFQUFzQkQsTUFBdEI7QUFHQVcsSUFBQUEsT0FBTyxDQUFDRSxFQUFSLENBQVcsT0FBWCxFQUFvQixNQUFPekIsS0FBUCxJQUFpQjtBQUNuQyxZQUFNMEIsR0FBRyxHQUFHLE1BQU1KLE9BQU8sQ0FBQztBQUN4QnRCLFFBQUFBLEtBRHdCO0FBRXhCMkIsUUFBQUEsY0FBYyxFQUFFLE1BQU8vQixPQUFQLElBQW1CLE1BQU1FLGVBQWUsQ0FBQ3lCLE9BQUQsRUFBVXZCLEtBQVYsRUFBaUJKLE9BQWpCO0FBRmhDLE9BQUQsQ0FBekI7O0FBSUEsVUFBSThCLEdBQUcsS0FBSyxLQUFaLEVBQW1CO0FBQ2pCLGVBQU9ILE9BQU8sQ0FBQ0ssSUFBUixDQUFhLEtBQWIsQ0FBUDtBQUNEOztBQUNETCxNQUFBQSxPQUFPLENBQUNNLFNBQVI7QUFDRCxLQVREO0FBVUQsR0FmNEIsQ0FBN0I7QUFnQkFOLEVBQUFBLE9BQU8sQ0FBQ00sU0FBUjtBQUdBLFNBQU8sTUFBTVgsb0JBQWI7QUFDRDs7QUE0QkQsZUFBZVksYUFBZixDQUE4QkMsT0FBOUIsRUFBdUNDLElBQUksR0FBRyxFQUE5QyxFQUFrRDtBQUNoRCxNQUFJLEVBQUMsTUFBTTFCLGFBQUdDLE1BQUgsQ0FBVXdCLE9BQVYsQ0FBUCxDQUFKLEVBQStCO0FBQzdCLFVBQU0sSUFBSUUsS0FBSixDQUFXLDJCQUEwQkYsT0FBUSxFQUE3QyxDQUFOO0FBQ0Q7O0FBRUQsUUFBTTtBQUNKRyxJQUFBQSxTQUFTLEdBQUcsSUFEUjtBQUVKQyxJQUFBQSxjQUFjLEdBQUcsS0FGYjtBQUdKQyxJQUFBQSxPQUFPLEdBQUcsSUFBSUMsU0FIVjtBQUlKQyxJQUFBQSxLQUFLLEdBQUc7QUFKSixNQUtGTixJQUxKO0FBTUEsUUFBTU8sYUFBYSxHQUFHLEVBQXRCO0FBQ0EsTUFBSUMsaUJBQWlCLEdBQUcsQ0FBeEI7QUFFQSxRQUFNQyxpQkFBaUIsR0FBRyxJQUFJQyxnQkFBT0MsUUFBWCxDQUFvQjtBQUM1Q0MsSUFBQUEsS0FBSyxFQUFFLENBQUNDLE1BQUQsRUFBU0MsUUFBVCxFQUFtQkMsSUFBbkIsS0FBNEI7QUFDakNSLE1BQUFBLGFBQWEsQ0FBQ1MsSUFBZCxDQUFtQkgsTUFBbkI7QUFDQUwsTUFBQUEsaUJBQWlCLElBQUlLLE1BQU0sQ0FBQ0ksTUFBNUI7O0FBQ0EsVUFBSWIsT0FBTyxHQUFHLENBQVYsSUFBZUksaUJBQWlCLEdBQUdKLE9BQXZDLEVBQWdEO0FBQzlDSyxRQUFBQSxpQkFBaUIsQ0FBQ2IsSUFBbEIsQ0FBdUIsT0FBdkIsRUFBZ0MsSUFBSUssS0FBSixDQUFXLDRCQUFELEdBQ3ZDLG9DQUFtQyxnQ0FBcUJHLE9BQXJCLENBQThCLEVBRHBDLENBQWhDO0FBRUQ7O0FBQ0RXLE1BQUFBLElBQUk7QUFDTDtBQVQyQyxHQUFwQixDQUExQjtBQWFBLFFBQU1HLE9BQU8sR0FBRyx1QkFBUyxLQUFULEVBQWdCO0FBQzlCQyxJQUFBQSxJQUFJLEVBQUU7QUFBQ2IsTUFBQUE7QUFBRDtBQUR3QixHQUFoQixDQUFoQjtBQUdBLE1BQUljLE9BQU8sR0FBRyxJQUFkO0FBQ0EsUUFBTUMsbUJBQW1CLEdBQUdsQixjQUFjLEdBQUcsSUFBSW1CLDBCQUFKLEVBQUgsR0FBd0IsSUFBbEU7QUFDQSxRQUFNQyx3QkFBd0IsR0FBRyxJQUFJbkUsaUJBQUosQ0FBTSxDQUFDZSxPQUFELEVBQVVTLE1BQVYsS0FBcUI7QUFDMUQ2QixJQUFBQSxpQkFBaUIsQ0FBQzVCLElBQWxCLENBQXVCLE9BQXZCLEVBQWlDMkMsQ0FBRCxJQUFPO0FBQ3JDLFVBQUlILG1CQUFKLEVBQXlCO0FBQ3ZCSCxRQUFBQSxPQUFPLENBQUNPLE1BQVIsQ0FBZUosbUJBQWY7QUFDQUEsUUFBQUEsbUJBQW1CLENBQUNJLE1BQXBCLENBQTJCaEIsaUJBQTNCO0FBQ0QsT0FIRCxNQUdPO0FBQ0xTLFFBQUFBLE9BQU8sQ0FBQ08sTUFBUixDQUFlaEIsaUJBQWY7QUFDRDs7QUFDRFMsTUFBQUEsT0FBTyxDQUFDUSxLQUFSO0FBQ0FSLE1BQUFBLE9BQU8sQ0FBQ1MsT0FBUjtBQUNBL0MsTUFBQUEsTUFBTSxDQUFDNEMsQ0FBRCxDQUFOO0FBQ0QsS0FWRDtBQVdBZixJQUFBQSxpQkFBaUIsQ0FBQzVCLElBQWxCLENBQXVCLFFBQXZCLEVBQWlDLE1BQU07QUFDckN1QyxNQUFBQSxPQUFPLEdBQUdGLE9BQU8sQ0FBQ1UsT0FBUixFQUFWO0FBQ0F6RCxNQUFBQSxPQUFPO0FBQ1IsS0FIRDtBQUlELEdBaEJnQyxDQUFqQztBQWlCQSxRQUFNMEQsb0JBQW9CLEdBQUcsSUFBSXpFLGlCQUFKLENBQU0sQ0FBQ2UsT0FBRCxFQUFVUyxNQUFWLEtBQXFCO0FBQ3REc0MsSUFBQUEsT0FBTyxDQUFDckMsSUFBUixDQUFhLFFBQWIsRUFBdUJWLE9BQXZCO0FBQ0ErQyxJQUFBQSxPQUFPLENBQUNyQyxJQUFSLENBQWEsT0FBYixFQUF1QjJDLENBQUQsSUFBTzVDLE1BQU0sQ0FDakMsSUFBSXFCLEtBQUosQ0FBVyxzQkFBcUJGLE9BQVEsTUFBS3lCLENBQUMsQ0FBQ00sT0FBUSxFQUF2RCxDQURpQyxDQUFuQztBQUVELEdBSjRCLENBQTdCO0FBS0EsUUFBTUMsS0FBSyxHQUFHN0IsU0FBUyxHQUFHLElBQUk4QixlQUFKLEdBQVlDLEtBQVosRUFBSCxHQUF5QixJQUFoRDs7QUFDQSxNQUFJLENBQUMsTUFBTTNELGFBQUc0RCxJQUFILENBQVFuQyxPQUFSLENBQVAsRUFBeUJvQyxXQUF6QixFQUFKLEVBQTRDO0FBQzFDakIsSUFBQUEsT0FBTyxDQUFDa0IsU0FBUixDQUFrQnJDLE9BQWxCLEVBQTJCLEtBQTNCO0FBQ0QsR0FGRCxNQUVPO0FBQ0xtQixJQUFBQSxPQUFPLENBQUNtQixJQUFSLENBQWF0QyxPQUFiLEVBQXNCO0FBQ3BCdUMsTUFBQUEsSUFBSSxFQUFFcEUsY0FBS3FFLFFBQUwsQ0FBY3hDLE9BQWQ7QUFEYyxLQUF0QjtBQUdEOztBQUNELE1BQUlzQixtQkFBSixFQUF5QjtBQUN2QkgsSUFBQUEsT0FBTyxDQUFDL0IsSUFBUixDQUFha0MsbUJBQWI7QUFDQUEsSUFBQUEsbUJBQW1CLENBQUNsQyxJQUFwQixDQUF5QnNCLGlCQUF6QjtBQUNELEdBSEQsTUFHTztBQUNMUyxJQUFBQSxPQUFPLENBQUMvQixJQUFSLENBQWFzQixpQkFBYjtBQUNEOztBQUNEUyxFQUFBQSxPQUFPLENBQUNzQixRQUFSO0FBR0EsUUFBTXBGLGtCQUFFZ0MsR0FBRixDQUFNLENBQUN5QyxvQkFBRCxFQUF1Qk4sd0JBQXZCLENBQU4sQ0FBTjs7QUFFQSxNQUFJUSxLQUFKLEVBQVc7QUFDVFUsb0JBQUlDLEtBQUosQ0FBVyxVQUFTdkMsY0FBYyxHQUFHLHFCQUFILEdBQTJCLEVBQUcsRUFBdEQsR0FDUCxJQUFHakMsY0FBS3FFLFFBQUwsQ0FBY3hDLE9BQWQsQ0FBdUIsSUFEbkIsSUFFUHFCLE9BQU8sR0FBSSxJQUFHLGdDQUFxQkEsT0FBckIsQ0FBOEIsSUFBckMsR0FBMkMsRUFGM0MsSUFHUCxNQUFLVyxLQUFLLENBQUNZLFdBQU4sR0FBb0JDLFNBQXBCLENBQThCQyxPQUE5QixDQUFzQyxDQUF0QyxDQUF5QyxJQUh2QyxHQUlQLHVCQUFzQnZDLEtBQU0sR0FKL0I7QUFLRDs7QUFFRCxTQUFPd0MsTUFBTSxDQUFDQyxNQUFQLENBQWN4QyxhQUFkLENBQVA7QUFDRDs7QUFRRCxlQUFleUMsY0FBZixDQUErQkMsUUFBL0IsRUFBeUM7QUFDdkMsTUFBSSxFQUFDLE1BQU0zRSxhQUFHQyxNQUFILENBQVUwRSxRQUFWLENBQVAsQ0FBSixFQUFnQztBQUM5QixVQUFNLElBQUloRCxLQUFKLENBQVcsZ0JBQWVnRCxRQUFTLGtCQUFuQyxDQUFOO0FBQ0Q7O0FBRUQsUUFBTTtBQUFDQyxJQUFBQTtBQUFELE1BQVMsTUFBTTVFLGFBQUc0RCxJQUFILENBQVFlLFFBQVIsQ0FBckI7O0FBQ0EsTUFBSUMsSUFBSSxHQUFHLENBQVgsRUFBYztBQUNaLFVBQU0sSUFBSWpELEtBQUosQ0FBVyxnQkFBZWdELFFBQVMsb0NBQW5DLENBQU47QUFDRDs7QUFDRCxRQUFNRSxFQUFFLEdBQUcsTUFBTTdFLGFBQUdmLElBQUgsQ0FBUTBGLFFBQVIsRUFBa0IsR0FBbEIsQ0FBakI7O0FBQ0EsTUFBSTtBQUNGLFVBQU1wQyxNQUFNLEdBQUdpQyxNQUFNLENBQUNNLEtBQVAsQ0FBYTNGLFNBQVMsQ0FBQ3dELE1BQXZCLENBQWY7QUFDQSxVQUFNM0MsYUFBRytFLElBQUgsQ0FBUUYsRUFBUixFQUFZdEMsTUFBWixFQUFvQixDQUFwQixFQUF1QnBELFNBQVMsQ0FBQ3dELE1BQWpDLEVBQXlDLENBQXpDLENBQU47QUFDQSxVQUFNcUMsU0FBUyxHQUFHekMsTUFBTSxDQUFDMEMsUUFBUCxDQUFnQixPQUFoQixDQUFsQjs7QUFDQSxRQUFJRCxTQUFTLEtBQUs3RixTQUFsQixFQUE2QjtBQUMzQixZQUFNLElBQUl3QyxLQUFKLENBQVcsdUJBQXNCcUQsU0FBVSxTQUFRTCxRQUFTLElBQWxELEdBQ2IsdURBQXNEeEYsU0FBVSxHQUQ3RCxDQUFOO0FBRUQ7O0FBQ0QsV0FBTyxJQUFQO0FBQ0QsR0FURCxTQVNVO0FBQ1IsVUFBTWEsYUFBR2tGLEtBQUgsQ0FBU0wsRUFBVCxDQUFOO0FBQ0Q7QUFDRjs7QUF3QkQsZUFBZU0sU0FBZixDQUEwQnhGLE9BQTFCLEVBQW1DeUYsR0FBRyxHQUFHLEVBQXpDLEVBQTZDMUQsSUFBSSxHQUFHLEVBQXBELEVBQXdEO0FBQ3RELFFBQU07QUFDSk0sSUFBQUEsS0FBSyxHQUFHO0FBREosTUFFRk4sSUFGSjtBQUdBLFFBQU07QUFDSjJELElBQUFBLE9BQU8sR0FBRyxNQUROO0FBRUpDLElBQUFBLEdBQUcsR0FBRzFGLGNBQUtNLE9BQUwsQ0FBYVAsT0FBYixDQUZGO0FBR0o0RixJQUFBQSxNQUFNLEdBQUc7QUFITCxNQUlGSCxHQUpKO0FBS0EsUUFBTXhDLE9BQU8sR0FBRyx1QkFBUyxLQUFULEVBQWdCO0FBQUVDLElBQUFBLElBQUksRUFBRTtBQUFFYixNQUFBQTtBQUFGO0FBQVIsR0FBaEIsQ0FBaEI7O0FBQ0EsUUFBTUksTUFBTSxHQUFHcEMsYUFBR3dGLGlCQUFILENBQXFCN0YsT0FBckIsQ0FBZjs7QUFDQSxTQUFPLE1BQU0sSUFBSWIsaUJBQUosQ0FBTSxDQUFDZSxPQUFELEVBQVVTLE1BQVYsS0FBcUI7QUFDdENzQyxJQUFBQSxPQUFPLENBQ0o2QyxJQURILENBQ1FKLE9BRFIsRUFDaUI7QUFDYkMsTUFBQUEsR0FEYTtBQUViQyxNQUFBQTtBQUZhLEtBRGpCLEVBS0dwRSxFQUxILENBS00sT0FMTixFQUtlYixNQUxmLEVBTUdPLElBTkgsQ0FNUXVCLE1BTlI7QUFPQUEsSUFBQUEsTUFBTSxDQUNIakIsRUFESCxDQUNNLE9BRE4sRUFDZ0IrQixDQUFELElBQU87QUFDbEJOLE1BQUFBLE9BQU8sQ0FBQ08sTUFBUixDQUFlZixNQUFmO0FBQ0FRLE1BQUFBLE9BQU8sQ0FBQ1EsS0FBUjtBQUNBUixNQUFBQSxPQUFPLENBQUNTLE9BQVI7QUFDQS9DLE1BQUFBLE1BQU0sQ0FBQzRDLENBQUQsQ0FBTjtBQUNELEtBTkgsRUFPRy9CLEVBUEgsQ0FPTSxRQVBOLEVBT2dCdEIsT0FQaEI7QUFRQStDLElBQUFBLE9BQU8sQ0FBQ3NCLFFBQVI7QUFDRCxHQWpCWSxDQUFiO0FBa0JEOztlQUljO0FBQUU5RSxFQUFBQSxZQUFGO0FBQWdCMkIsRUFBQUEsV0FBaEI7QUFBNkJTLEVBQUFBLGFBQTdCO0FBQTRDa0QsRUFBQUEsY0FBNUM7QUFBNERTLEVBQUFBO0FBQTVELEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgbm9kZUV4dHJhY3QgZnJvbSAnZXh0cmFjdC16aXAnO1xuaW1wb3J0IHlhdXpsIGZyb20gJ3lhdXpsJztcbmltcG9ydCBhcmNoaXZlciBmcm9tICdhcmNoaXZlcic7XG5pbXBvcnQgeyBjcmVhdGVXcml0ZVN0cmVhbSB9IGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgbWtkaXJwIH0gZnJvbSAnLi4vbGliL21rZGlycCc7XG5pbXBvcnQgc3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgZnMgZnJvbSAnLi9mcyc7XG5pbXBvcnQgeyBCYXNlNjRFbmNvZGUgfSBmcm9tICdiYXNlNjQtc3RyZWFtJztcbmltcG9ydCB7IHRvUmVhZGFibGVTaXplU3RyaW5nLCBHaUIgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vdGltaW5nJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuXG5jb25zdCBleHRyYWN0ID0gQi5wcm9taXNpZnkobm9kZUV4dHJhY3QpO1xuY29uc3Qgb3BlbiA9IEIucHJvbWlzaWZ5KHlhdXpsLm9wZW4pO1xuY29uc3QgWklQX01BR0lDID0gJ1BLJztcblxuLyoqXG4gKiBFeHRyYWN0IHppcGZpbGUgdG8gYSBkaXJlY3RvcnlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gemlwRmlsZVBhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgc291cmNlIFpJUCBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEFsbFRvICh6aXBGaWxlUGF0aCwgZGVzdERpcikge1xuICByZXR1cm4gYXdhaXQgZXh0cmFjdCh6aXBGaWxlUGF0aCwge2RpcjogZGVzdERpcn0pO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBzaW5nbGUgemlwIGVudHJ5IHRvIGEgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtIHtTdHJlYW1hYmxlfSB6aXBGaWxlIFRoZSBzb3VyY2UgWklQIHN0cmVhbVxuICogQHBhcmFtIHt5YXV6bC5aaXBFbnRyeX0gZW50cnkgVGhlIGVudHJ5IGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2V4dHJhY3RFbnRyeVRvICh6aXBGaWxlLCBlbnRyeSwgZGVzdERpcikge1xuICBjb25zdCBkc3RQYXRoID0gcGF0aC5yZXNvbHZlKGRlc3REaXIsIGVudHJ5LmZpbGVOYW1lKTtcblxuICAvLyBDcmVhdGUgZGVzdCBkaXJlY3RvcnkgaWYgZG9lc24ndCBleGlzdCBhbHJlYWR5XG4gIGlmICgvXFwvJC8udGVzdChlbnRyeS5maWxlTmFtZSkpIHtcbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhkc3RQYXRoKSkge1xuICAgICAgYXdhaXQgbWtkaXJwKGRzdFBhdGgpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIWF3YWl0IGZzLmV4aXN0cyhwYXRoLmRpcm5hbWUoZHN0UGF0aCkpKSB7XG4gICAgYXdhaXQgbWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSB3cml0ZSBzdHJlYW1cbiAgY29uc3Qgd3JpdGVTdHJlYW0gPSBjcmVhdGVXcml0ZVN0cmVhbShkc3RQYXRoLCB7ZmxhZ3M6ICd3J30pO1xuICBjb25zdCB3cml0ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd3JpdGVTdHJlYW0ub25jZSgnZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgd3JpdGVTdHJlYW0ub25jZSgnZXJyb3InLCByZWplY3QpO1xuICB9KTtcblxuICAvLyBDcmVhdGUgemlwUmVhZFN0cmVhbSBhbmQgcGlwZSBkYXRhIHRvIHRoZSB3cml0ZSBzdHJlYW1cbiAgLy8gKGZvciBzb21lIG9kZCByZWFzb24gQi5wcm9taXNpZnkgZG9lc24ndCB3b3JrIG9uIHppcGZpbGUub3BlblJlYWRTdHJlYW0sIGl0IGNhdXNlcyBhbiBlcnJvciAnY2xvc2VkJylcbiAgY29uc3QgemlwUmVhZFN0cmVhbSA9IGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB6aXBGaWxlLm9wZW5SZWFkU3RyZWFtKGVudHJ5LCAoZXJyLCByZWFkU3RyZWFtKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVhZFN0cmVhbSkpO1xuICB9KTtcbiAgY29uc3QgemlwUmVhZFN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgemlwUmVhZFN0cmVhbS5vbmNlKCdlbmQnLCByZXNvbHZlKTtcbiAgICB6aXBSZWFkU3RyZWFtLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgfSk7XG4gIHppcFJlYWRTdHJlYW0ucGlwZSh3cml0ZVN0cmVhbSk7XG5cbiAgLy8gV2FpdCBmb3IgdGhlIHppcFJlYWRTdHJlYW0gYW5kIHdyaXRlU3RyZWFtIHRvIGVuZCBiZWZvcmUgcmV0dXJuaW5nXG4gIHJldHVybiBhd2FpdCBCLmFsbChbXG4gICAgemlwUmVhZFN0cmVhbVByb21pc2UsXG4gICAgd3JpdGVTdHJlYW1Qcm9taXNlLFxuICBdKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBaaXBFbnRyeVxuICogQHByb3BlcnR5IHt5YXV6bC5aaXBFbnRyeX0gZW50cnkgVGhlIGFjdHVhbCBlbnRyeSBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZXh0cmFjdEVudHJ5VG8gQW4gYXN5bmMgZnVuY3Rpb24sIHdoaWNoIGFjY2VwdHMgb25lIHBhcmFtZXRlci5cbiAqIFRoaXMgcGFyYW1ldGVyIGNvbnRhaW5zIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIgcGF0aCB0byB3aGljaCB0aGlzIGZ1bmN0aW9uIGlzIGdvaW5nIHRvIGV4dHJhY3QgdGhlIGVudHJ5LlxuICovXG5cbi8qKlxuICogR2V0IGVudHJpZXMgZm9yIGEgemlwIGZvbGRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB6aXBGaWxlUGF0aCBUaGUgZnVsbCBwYXRoIHRvIHRoZSBzb3VyY2UgWklQIGZpbGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uRW50cnkgQ2FsbGJhY2sgd2hlbiBlbnRyeSBpcyByZWFkLlxuICogVGhlIGNhbGxiYWNrIGlzIGV4cGVjdGVkIHRvIGFjY2VwdCBvbmUgYXJndW1lbnQgb2YgWmlwRW50cnkgdHlwZS5cbiAqIFRoZSBpdGVyYXRpb24gdGhyb3VnaCB0aGUgc291cmNlIHppcCBmaWxlIHdpbGwgYmkgdGVybWluYXRlZCBhcyBzb29uIGFzXG4gKiB0aGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gZXF1YWxzIHRvIGBmYWxzZWAuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRFbnRyaWVzICh6aXBGaWxlUGF0aCwgb25FbnRyeSkge1xuICAvLyBPcGVuIGEgemlwIGZpbGUgYW5kIHN0YXJ0IHJlYWRpbmcgZW50cmllc1xuICBjb25zdCB6aXBmaWxlID0gYXdhaXQgb3Blbih6aXBGaWxlUGF0aCwge2xhenlFbnRyaWVzOiB0cnVlfSk7XG4gIGNvbnN0IHppcFJlYWRTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHppcGZpbGUub25jZSgnZW5kJywgcmVzb2x2ZSk7XG4gICAgemlwZmlsZS5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG5cbiAgICAvLyBPbiBlYWNoIGVudHJ5LCBjYWxsICdvbkVudHJ5JyBhbmQgdGhlbiByZWFkIHRoZSBuZXh0IGVudHJ5XG4gICAgemlwZmlsZS5vbignZW50cnknLCBhc3luYyAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG9uRW50cnkoe1xuICAgICAgICBlbnRyeSxcbiAgICAgICAgZXh0cmFjdEVudHJ5VG86IGFzeW5jIChkZXN0RGlyKSA9PiBhd2FpdCBfZXh0cmFjdEVudHJ5VG8oemlwZmlsZSwgZW50cnksIGRlc3REaXIpXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB6aXBmaWxlLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHppcGZpbGUucmVhZEVudHJ5KCk7XG5cbiAgLy8gV2FpdCBmb3IgdGhlIGVudHJpZXMgdG8gZmluaXNoIGJlaW5nIGl0ZXJhdGVkIHRocm91Z2hcbiAgcmV0dXJuIGF3YWl0IHppcFJlYWRTdHJlYW1Qcm9taXNlO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFppcE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5jb2RlVG9CYXNlNjQgW2ZhbHNlXSBXaGV0aGVyIHRvIGVuY29kZVxuICogdGhlIHJlc3VsdGluZyBhcmNoaXZlIHRvIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzTWV0ZXJlZCBbdHJ1ZV0gV2hldGhlciB0byBsb2cgdGhlIGFjdHVhbFxuICogYXJjaGl2ZXIgcGVyZm9ybWFuY2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhTaXplIFsxMDczNzQxODI0XSBUaGUgbWF4aW11bSBzaXplIG9mXG4gKiB0aGUgcmVzdWx0aW5nIGFyY2hpdmUgaW4gYnl0ZXMuIFRoaXMgaXMgc2V0IHRvIDFHQiBieSBkZWZhdWx0LCBiZWNhdXNlXG4gKiBBcHBpdW0gbGltaXRzIHRoZSBtYXhpbXVtIEhUVFAgYm9keSBzaXplIHRvIDFHQi4gQWxzbywgdGhlIE5vZGVKUyBoZWFwXG4gKiBzaXplIG11c3QgYmUgZW5vdWdoIHRvIGtlZXAgdGhlIHJlc3VsdGluZyBvYmplY3QgKHVzdWFsbHkgdGhpcyBzaXplIGlzXG4gKiBsaW1pdGVkIHRvIDEuNCBHQilcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbCBbOV0gVGhlIGNvbXByZXNzaW9uIGxldmVsLiBUaGUgbWF4aW11bVxuICogbGV2ZWwgaXMgOSAodGhlIGJlc3QgY29tcHJlc3Npb24sIHdvcnN0IHBlcmZvcm1hbmNlKS4gVGhlIG1pbmltdW1cbiAqIGNvbXByZXNzaW9uIGxldmVsIGlzIDAgKG5vIGNvbXByZXNzaW9uKS5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIGNvbnRlbnRzIG9mIGxvY2FsIGRpcmVjdG9yeSB0byBhbiBpbi1tZW1vcnkgLnppcCBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjUGF0aCBUaGUgZnVsbCBwYXRoIHRvIHRoZSBmb2xkZXIgb3IgZmlsZSBiZWluZyB6aXBwZWRcbiAqIEBwYXJhbSB7WmlwT3B0aW9uc30gb3B0cyBaaXBwaW5nIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFppcHBlZCAoYW5kIGVuY29kZWQgaWYgYGVuY29kZVRvQmFzZTY0YCBpcyB0cnV0aHkpXG4gKiBjb250ZW50IG9mIHRoZSBzb3VyY2UgcGF0aCBhcyBtZW1vcnkgYnVmZmVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHJlYWRpbmcgdGhlIHNvdXJjZVxuICogb3IgdGhlIHNvdXJjZSBpcyB0b28gYmlnXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRvSW5NZW1vcnlaaXAgKHNyY1BhdGgsIG9wdHMgPSB7fSkge1xuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhzcmNQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3VjaCBmaWxlIG9yIGZvbGRlcjogJHtzcmNQYXRofWApO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGlzTWV0ZXJlZCA9IHRydWUsXG4gICAgZW5jb2RlVG9CYXNlNjQgPSBmYWxzZSxcbiAgICBtYXhTaXplID0gMSAqIEdpQixcbiAgICBsZXZlbCA9IDksXG4gIH0gPSBvcHRzO1xuICBjb25zdCByZXN1bHRCdWZmZXJzID0gW107XG4gIGxldCByZXN1bHRCdWZmZXJzU2l6ZSA9IDA7XG4gIC8vIENyZWF0ZSBhIHdyaXRhYmxlIHN0cmVhbSB0aGF0IHppcCBidWZmZXJzIHdpbGwgYmUgc3RyZWFtZWQgdG9cbiAgY29uc3QgcmVzdWx0V3JpdGVTdHJlYW0gPSBuZXcgc3RyZWFtLldyaXRhYmxlKHtcbiAgICB3cml0ZTogKGJ1ZmZlciwgZW5jb2RpbmcsIG5leHQpID0+IHtcbiAgICAgIHJlc3VsdEJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgICAgcmVzdWx0QnVmZmVyc1NpemUgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIGlmIChtYXhTaXplID4gMCAmJiByZXN1bHRCdWZmZXJzU2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgcmVzdWx0V3JpdGVTdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoYFRoZSBzaXplIG9mIHRoZSByZXN1bHRpbmcgYCArXG4gICAgICAgICAgYGFyY2hpdmUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuICR7dG9SZWFkYWJsZVNpemVTdHJpbmcobWF4U2l6ZSl9YCkpO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8vIFppcCAnc3JjRGlyJyBhbmQgc3RyZWFtIGl0IHRvIHRoZSBhYm92ZSB3cml0YWJsZSBzdHJlYW1cbiAgY29uc3QgYXJjaGl2ZSA9IGFyY2hpdmVyKCd6aXAnLCB7XG4gICAgemxpYjoge2xldmVsfVxuICB9KTtcbiAgbGV0IHNyY1NpemUgPSBudWxsO1xuICBjb25zdCBiYXNlNjRFbmNvZGVyU3RyZWFtID0gZW5jb2RlVG9CYXNlNjQgPyBuZXcgQmFzZTY0RW5jb2RlKCkgOiBudWxsO1xuICBjb25zdCByZXN1bHRXcml0ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzdWx0V3JpdGVTdHJlYW0ub25jZSgnZXJyb3InLCAoZSkgPT4ge1xuICAgICAgaWYgKGJhc2U2NEVuY29kZXJTdHJlYW0pIHtcbiAgICAgICAgYXJjaGl2ZS51bnBpcGUoYmFzZTY0RW5jb2RlclN0cmVhbSk7XG4gICAgICAgIGJhc2U2NEVuY29kZXJTdHJlYW0udW5waXBlKHJlc3VsdFdyaXRlU3RyZWFtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyY2hpdmUudW5waXBlKHJlc3VsdFdyaXRlU3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIGFyY2hpdmUuYWJvcnQoKTtcbiAgICAgIGFyY2hpdmUuZGVzdHJveSgpO1xuICAgICAgcmVqZWN0KGUpO1xuICAgIH0pO1xuICAgIHJlc3VsdFdyaXRlU3RyZWFtLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIHNyY1NpemUgPSBhcmNoaXZlLnBvaW50ZXIoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IGFyY2hpdmVTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGFyY2hpdmUub25jZSgnZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgYXJjaGl2ZS5vbmNlKCdlcnJvcicsIChlKSA9PiByZWplY3QoXG4gICAgICBuZXcgRXJyb3IoYEZhaWxlZCB0byBhcmNoaXZlICcke3NyY1BhdGh9JzogJHtlLm1lc3NhZ2V9YCkpKTtcbiAgfSk7XG4gIGNvbnN0IHRpbWVyID0gaXNNZXRlcmVkID8gbmV3IFRpbWVyKCkuc3RhcnQoKSA6IG51bGw7XG4gIGlmICgoYXdhaXQgZnMuc3RhdChzcmNQYXRoKSkuaXNEaXJlY3RvcnkoKSkge1xuICAgIGFyY2hpdmUuZGlyZWN0b3J5KHNyY1BhdGgsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBhcmNoaXZlLmZpbGUoc3JjUGF0aCwge1xuICAgICAgbmFtZTogcGF0aC5iYXNlbmFtZShzcmNQYXRoKSxcbiAgICB9KTtcbiAgfVxuICBpZiAoYmFzZTY0RW5jb2RlclN0cmVhbSkge1xuICAgIGFyY2hpdmUucGlwZShiYXNlNjRFbmNvZGVyU3RyZWFtKTtcbiAgICBiYXNlNjRFbmNvZGVyU3RyZWFtLnBpcGUocmVzdWx0V3JpdGVTdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIGFyY2hpdmUucGlwZShyZXN1bHRXcml0ZVN0cmVhbSk7XG4gIH1cbiAgYXJjaGl2ZS5maW5hbGl6ZSgpO1xuXG4gIC8vIFdhaXQgZm9yIHRoZSBzdHJlYW1zIHRvIGZpbmlzaFxuICBhd2FpdCBCLmFsbChbYXJjaGl2ZVN0cmVhbVByb21pc2UsIHJlc3VsdFdyaXRlU3RyZWFtUHJvbWlzZV0pO1xuXG4gIGlmICh0aW1lcikge1xuICAgIGxvZy5kZWJ1ZyhgWmlwcGVkICR7ZW5jb2RlVG9CYXNlNjQgPyAnYW5kIGJhc2U2NC1lbmNvZGVkICcgOiAnJ31gICtcbiAgICAgIGAnJHtwYXRoLmJhc2VuYW1lKHNyY1BhdGgpfScgYCArXG4gICAgICAoc3JjU2l6ZSA/IGAoJHt0b1JlYWRhYmxlU2l6ZVN0cmluZyhzcmNTaXplKX0pIGAgOiAnJykgK1xuICAgICAgYGluICR7dGltZXIuZ2V0RHVyYXRpb24oKS5hc1NlY29uZHMudG9GaXhlZCgzKX1zIGAgK1xuICAgICAgYChjb21wcmVzc2lvbiBsZXZlbDogJHtsZXZlbH0pYCk7XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSBhcnJheSBvZiB6aXAgYnVmZmVycyBjb25jYXRlbmF0ZWQgaW50byBvbmUgYnVmZmVyXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KHJlc3VsdEJ1ZmZlcnMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHdoZXRoZXIgdGhlIGdpdmVuIGZpbGUgaXMgYSB2YWxpZCBaSVAgYXJjaGl2ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlUGF0aCAtIEZ1bGwgcGF0aCB0byB0aGUgZmlsZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBhIHZhbGlkIFpJUCBhcmNoaXZlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFzc2VydFZhbGlkWmlwIChmaWxlUGF0aCkge1xuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhmaWxlUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmaWxlIGF0ICcke2ZpbGVQYXRofScgZG9lcyBub3QgZXhpc3RgKTtcbiAgfVxuXG4gIGNvbnN0IHtzaXplfSA9IGF3YWl0IGZzLnN0YXQoZmlsZVBhdGgpO1xuICBpZiAoc2l6ZSA8IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmaWxlIGF0ICcke2ZpbGVQYXRofScgaXMgdG9vIHNtYWxsIHRvIGJlIGEgWklQIGFyY2hpdmVgKTtcbiAgfVxuICBjb25zdCBmZCA9IGF3YWl0IGZzLm9wZW4oZmlsZVBhdGgsICdyJyk7XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKFpJUF9NQUdJQy5sZW5ndGgpO1xuICAgIGF3YWl0IGZzLnJlYWQoZmQsIGJ1ZmZlciwgMCwgWklQX01BR0lDLmxlbmd0aCwgMCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYnVmZmVyLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgIGlmIChzaWduYXR1cmUgIT09IFpJUF9NQUdJQykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlsZSBzaWduYXR1cmUgJyR7c2lnbmF0dXJlfScgb2YgJyR7ZmlsZVBhdGh9JyBgICtcbiAgICAgICAgYGlzIG5vdCBlcXVhbCB0byB0aGUgZXhwZWN0ZWQgWklQIGFyY2hpdmUgc2lnbmF0dXJlICcke1pJUF9NQUdJQ30nYCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLmNsb3NlKGZkKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFppcENvbXByZXNzaW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsIFs5XSAtIENvbXByZXNzaW9uIGxldmVsIGluIHJhbmdlIDAuLjlcbiAqIChncmVhdGVyIG51bWJlcnMgbWVhbiBiZXR0ZXIgY29tcHJlc3Npb24sIGJ1dCBsb25nZXIgcHJvY2Vzc2luZyB0aW1lKVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gWmlwU291cmNlT3B0aW9uc1xuICogQHByb3BlcnR5IHshc3RyaW5nfSBwYXR0ZXJuIFsnKipcXC8qJ10gLSBHTE9CIHBhdHRlcm4gZm9yIGNvbXByZXNzaW9uXG4gKiBAcHJvcGVydHkgeyFzdHJpbmd9IGN3ZCAtIFRoZSBzb3VyY2Ugcm9vdCBmb2xkZXIgKHRoZSBwYXJlbnQgZm9sZGVyIG9mXG4gKiB0aGUgZGVzdGluYXRpb24gZmlsZSBieSBkZWZhdWx0KVxuICogQHByb3BlcnR5IHs/QXJyYXk8c3RyaW5nPn0gaWdub3JlIC0gVGhlIGxpc3Qgb2YgaWdub3JlZCBwYXR0ZXJuc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcmNoaXZlIGJhc2VkIG9uIHRoZSBnaXZlbiBnbG9iIHBhdHRlcm5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZHN0UGF0aCAtIFRoZSByZXN1bHRpbmcgYXJjaGl2ZSBwYXRoXG4gKiBAcGFyYW0ge1ppcFNvdXJjZU9wdGlvbnN9IHNyYyAtIFNvdXJjZSBvcHRpb25zXG4gKiBAcGFyYW0ge1ppcENvbXByZXNzaW9uT3B0aW9uc30gb3B0cyAtIENvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIGFyY2hpdmVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdG9BcmNoaXZlIChkc3RQYXRoLCBzcmMgPSB7fSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBsZXZlbCA9IDksXG4gIH0gPSBvcHRzO1xuICBjb25zdCB7XG4gICAgcGF0dGVybiA9ICcqKi8qJyxcbiAgICBjd2QgPSBwYXRoLmRpcm5hbWUoZHN0UGF0aCksXG4gICAgaWdub3JlID0gW10sXG4gIH0gPSBzcmM7XG4gIGNvbnN0IGFyY2hpdmUgPSBhcmNoaXZlcignemlwJywgeyB6bGliOiB7IGxldmVsIH19KTtcbiAgY29uc3Qgc3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZHN0UGF0aCk7XG4gIHJldHVybiBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYXJjaGl2ZVxuICAgICAgLmdsb2IocGF0dGVybiwge1xuICAgICAgICBjd2QsXG4gICAgICAgIGlnbm9yZSxcbiAgICAgIH0pXG4gICAgICAub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgLnBpcGUoc3RyZWFtKTtcbiAgICBzdHJlYW1cbiAgICAgIC5vbignZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICBhcmNoaXZlLnVucGlwZShzdHJlYW0pO1xuICAgICAgICBhcmNoaXZlLmFib3J0KCk7XG4gICAgICAgIGFyY2hpdmUuZGVzdHJveSgpO1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9KVxuICAgICAgLm9uKCdmaW5pc2gnLCByZXNvbHZlKTtcbiAgICBhcmNoaXZlLmZpbmFsaXplKCk7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBleHRyYWN0QWxsVG8sIHJlYWRFbnRyaWVzLCB0b0luTWVtb3J5WmlwLCBfZXh0cmFjdEVudHJ5VG8sXG4gIGFzc2VydFZhbGlkWmlwLCB0b0FyY2hpdmUgfTtcbmV4cG9ydCBkZWZhdWx0IHsgZXh0cmFjdEFsbFRvLCByZWFkRW50cmllcywgdG9Jbk1lbW9yeVppcCwgYXNzZXJ0VmFsaWRaaXAsIHRvQXJjaGl2ZSB9O1xuIl0sImZpbGUiOiJsaWIvemlwLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
