"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Chromedriver = void 0;

require("source-map-support/register");

var _events = _interopRequireDefault(require("events"));

var _appiumBaseDriver = require("appium-base-driver");

var _child_process = _interopRequireDefault(require("child_process"));

var _appiumSupport = require("appium-support");

var _asyncbox = require("asyncbox");

var _teen_process = require("teen_process");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _utils = require("./utils");

var _semver = _interopRequireDefault(require("semver"));

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _compareVersions = _interopRequireDefault(require("compare-versions"));

var _storageClient = _interopRequireDefault(require("./storage-client"));

var _protocolHelpers = require("./protocol-helpers");

const log = _appiumSupport.logger.getLogger('Chromedriver');

const NEW_CD_VERSION_FORMAT_MAJOR_VERSION = 73;
const DEFAULT_HOST = '127.0.0.1';
const MIN_CD_VERSION_WITH_W3C_SUPPORT = 75;
const DEFAULT_PORT = 9515;
const CHROME_BUNDLE_ID = 'com.android.chrome';
const WEBVIEW_SHELL_BUNDLE_ID = 'org.chromium.webview_shell';
const WEBVIEW_BUNDLE_IDS = ['com.google.android.webview', 'com.android.webview'];
const CHROMEDRIVER_TUTORIAL = 'https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/web/chromedriver.md';
const VERSION_PATTERN = /([\d.]+)/;
const CD_VERSION_TIMEOUT = 5000;

class Chromedriver extends _events.default.EventEmitter {
  constructor(args = {}) {
    super();
    const {
      host = DEFAULT_HOST,
      port = DEFAULT_PORT,
      useSystemExecutable = false,
      executable,
      executableDir = (0, _utils.getChromedriverDir)(),
      bundleId,
      mappingPath,
      cmdArgs,
      adb,
      verbose,
      logPath,
      disableBuildCheck,
      details,
      isAutodownloadEnabled = false
    } = args;
    this.proxyHost = host;
    this.proxyPort = port;
    this.adb = adb;
    this.cmdArgs = cmdArgs;
    this.proc = null;
    this.useSystemExecutable = useSystemExecutable;
    this.chromedriver = executable;
    this.executableDir = executableDir;
    this.mappingPath = mappingPath;
    this.bundleId = bundleId;
    this.executableVerified = false;
    this.state = Chromedriver.STATE_STOPPED;
    this.jwproxy = new _appiumBaseDriver.JWProxy({
      server: this.proxyHost,
      port: this.proxyPort
    });
    this.verbose = verbose;
    this.logPath = logPath;
    this.disableBuildCheck = !!disableBuildCheck;
    this.storageClient = isAutodownloadEnabled ? new _storageClient.default({
      chromedriverDir: this.executableDir
    }) : null;
    this.details = details;
    this.capabilities = {};
    this.desiredProtocol = _appiumBaseDriver.PROTOCOLS.MJSONWP;
  }

  async getMapping() {
    let mapping = _lodash.default.cloneDeep(_utils.CHROMEDRIVER_CHROME_MAPPING);

    if (this.mappingPath) {
      log.debug(`Attempting to use Chromedriver-Chrome mapping from '${this.mappingPath}'`);

      if (!(await _appiumSupport.fs.exists(this.mappingPath))) {
        log.warn(`No file found at '${this.mappingPath}'. Using default mapping`);
      } else {
        try {
          mapping = JSON.parse(await _appiumSupport.fs.readFile(this.mappingPath, 'utf8'));
        } catch (err) {
          log.error(`Error parsing mapping from '${this.mappingPath}': ${err.message}`);
          log.warn('Using default mapping');
        }
      }
    }

    for (const [cdVersion, chromeVersion] of _lodash.default.toPairs(mapping)) {
      const coercedVersion = _semver.default.coerce(chromeVersion);

      if (coercedVersion) {
        mapping[cdVersion] = coercedVersion.version;
      } else {
        log.info(`'${chromeVersion}' is not a valid version number. Skipping it`);
      }
    }

    return mapping;
  }

  async getChromedrivers(mapping) {
    const executables = await _appiumSupport.fs.glob(`${this.executableDir}/*`);
    log.debug(`Found ${_appiumSupport.util.pluralize('executable', executables.length, true)} ` + `in '${this.executableDir}'`);
    const cds = (await (0, _asyncbox.asyncmap)(executables, async function mapChromedriver(executable) {
      const logError = ({
        message,
        stdout = null,
        stderr = null
      }) => {
        let errMsg = `Cannot retrieve version number from '${_path.default.basename(executable)}' Chromedriver binary. ` + `Make sure it returns a valid version string in response to '--version' command line argument. ${message}`;

        if (stdout) {
          errMsg += `\nStdout: ${stdout}`;
        }

        if (stderr) {
          errMsg += `\nStderr: ${stderr}`;
        }

        log.warn(errMsg);
        return null;
      };

      let stdout;
      let stderr;

      try {
        ({
          stdout,
          stderr
        } = await (0, _teen_process.exec)(executable, ['--version'], {
          timeout: CD_VERSION_TIMEOUT
        }));
      } catch (err) {
        if (!(err.message || '').includes('timed out') && !(err.stdout || '').includes('Starting ChromeDriver')) {
          return logError(err);
        }

        stdout = err.stdout;
      }

      const match = /ChromeDriver\s+\(?v?([\d.]+)\)?/i.exec(stdout);

      if (!match) {
        return logError({
          message: 'Cannot parse the version string',
          stdout,
          stderr
        });
      }

      let version = match[1];
      let minChromeVersion = mapping[version];

      const coercedVersion = _semver.default.coerce(version);

      if (coercedVersion) {
        if (coercedVersion.major < NEW_CD_VERSION_FORMAT_MAJOR_VERSION) {
          version = `${coercedVersion.major}.${coercedVersion.minor}`;
          minChromeVersion = mapping[version];
        }

        if (!minChromeVersion && coercedVersion.major >= NEW_CD_VERSION_FORMAT_MAJOR_VERSION) {
          minChromeVersion = `${coercedVersion.major}`;
        }
      }

      return {
        executable,
        version,
        minChromeVersion
      };
    })).filter(cd => !!cd).sort((a, b) => (0, _compareVersions.default)(b.version, a.version));

    if (_lodash.default.isEmpty(cds)) {
      log.info(`No Chromedrivers were found in '${this.executableDir}'`);
      return cds;
    }

    log.debug(`The following Chromedriver executables were found:`);

    for (const cd of cds) {
      log.debug(`    '${cd.executable}' (version '${cd.version}', minimum Chrome version '${cd.minChromeVersion ? cd.minChromeVersion : 'Unknown'}')`);
    }

    return cds;
  }

  async getChromeVersion() {
    var _this$details, _this$details3, _this$details3$info;

    if ((_this$details = this.details) === null || _this$details === void 0 ? void 0 : _this$details.info) {
      var _this$details2, _this$details2$info;

      log.debug(`Browser version in the supplied details: ${(_this$details2 = this.details) === null || _this$details2 === void 0 ? void 0 : (_this$details2$info = _this$details2.info) === null || _this$details2$info === void 0 ? void 0 : _this$details2$info.Browser}`);
    }

    const versionMatch = VERSION_PATTERN.exec((_this$details3 = this.details) === null || _this$details3 === void 0 ? void 0 : (_this$details3$info = _this$details3.info) === null || _this$details3$info === void 0 ? void 0 : _this$details3$info.Browser);

    if (versionMatch) {
      const coercedVersion = _semver.default.coerce(versionMatch[1]);

      if (coercedVersion) {
        return coercedVersion;
      }
    }

    let chromeVersion;

    if (this.bundleId === WEBVIEW_SHELL_BUNDLE_ID) {
      for (const bundleId of WEBVIEW_BUNDLE_IDS) {
        chromeVersion = await (0, _utils.getChromeVersion)(this.adb, bundleId);

        if (chromeVersion) {
          this.bundleId = bundleId;
          return _semver.default.coerce(chromeVersion);
        }
      }

      return null;
    }

    if (this.adb) {
      const apiLevel = await this.adb.getApiLevel();

      if (apiLevel >= 24 && apiLevel <= 28) {
        this.bundleId = CHROME_BUNDLE_ID;
      }
    }

    if (!this.bundleId) {
      this.bundleId = CHROME_BUNDLE_ID;

      for (const bundleId of WEBVIEW_BUNDLE_IDS) {
        chromeVersion = await (0, _utils.getChromeVersion)(this.adb, bundleId);

        if (chromeVersion) {
          this.bundleId = bundleId;
          break;
        }
      }
    }

    if (!chromeVersion) {
      chromeVersion = await (0, _utils.getChromeVersion)(this.adb, this.bundleId);
    }

    return chromeVersion ? _semver.default.coerce(chromeVersion) : null;
  }

  async getCompatibleChromedriver() {
    if (!this.adb) {
      return await (0, _utils.getChromedriverBinaryPath)();
    }

    const mapping = await this.getMapping();
    let didStorageSync = false;

    const syncChromedrivers = async chromeVersion => {
      didStorageSync = true;
      const retrievedMapping = await this.storageClient.retrieveMapping();
      log.debug('Got chromedrivers mapping from the storage: ' + JSON.stringify(retrievedMapping, null, 2));
      const driverKeys = await this.storageClient.syncDrivers({
        minBrowserVersion: chromeVersion.major
      });

      if (_lodash.default.isEmpty(driverKeys)) {
        return false;
      }

      const synchronizedDriversMapping = driverKeys.reduce((acc, x) => {
        const {
          version,
          minBrowserVersion
        } = retrievedMapping[x];
        acc[version] = minBrowserVersion;
        return acc;
      }, {});
      Object.assign(mapping, synchronizedDriversMapping);
      let shouldUpdateStaticMapping = true;

      if (await _appiumSupport.fs.exists(this.mappingPath)) {
        try {
          await _appiumSupport.fs.writeFile(this.mappingPath, JSON.stringify(mapping, null, 2), 'utf8');
          shouldUpdateStaticMapping = false;
        } catch (e) {
          log.warn(`Cannot store the updated chromedrivers mapping into '${this.mappingPath}'. ` + `This may reduce the performance of further executions. Original error: ${e.message}`);
        }
      }

      if (shouldUpdateStaticMapping) {
        Object.assign(_utils.CHROMEDRIVER_CHROME_MAPPING, mapping);
      }

      return true;
    };

    do {
      var _semver$coerce;

      const cds = await this.getChromedrivers(mapping);

      if (this.disableBuildCheck) {
        if (_lodash.default.isEmpty(cds)) {
          log.errorAndThrow(`There must be at least one Chromedriver executable available for use if ` + `'chromedriverDisableBuildCheck' capability is set to 'true'`);
        }

        const {
          version,
          executable
        } = cds[0];
        log.warn(`Chrome build check disabled. Using most recent Chromedriver version (${version}, at '${executable}')`);
        log.warn(`If this is wrong, set 'chromedriverDisableBuildCheck' capability to 'false'`);
        return executable;
      }

      const chromeVersion = await this.getChromeVersion();

      if (!chromeVersion) {
        if (_lodash.default.isEmpty(cds)) {
          log.errorAndThrow(`There must be at least one Chromedriver executable available for use if ` + `the current Chrome version cannot be determined`);
        }

        const {
          version,
          executable
        } = cds[0];
        log.warn(`Unable to discover Chrome version. Using Chromedriver ${version} at '${executable}'`);
        return executable;
      }

      log.debug(`Found Chrome bundle '${this.bundleId}' version '${chromeVersion}'`);

      if (!_lodash.default.isEmpty(mapping)) {
        log.debug(`The most recent known Chrome version: ${_lodash.default.values(mapping)[0]}`);
      }

      const autodownloadSuggestion = 'You could also try to enable automated chromedrivers download server feature';

      if (_lodash.default.isEmpty(mapping) || chromeVersion.major > ((_semver$coerce = _semver.default.coerce(_lodash.default.values(mapping)[0])) === null || _semver$coerce === void 0 ? void 0 : _semver$coerce.major)) {
        if (this.storageClient && !didStorageSync) {
          try {
            if (await syncChromedrivers(chromeVersion)) {
              continue;
            }
          } catch (e) {
            log.warn(`Cannot synchronize local chromedrivers with the remote storage at ${_utils.CD_CDN}: ` + e.message);
            log.debug(e);
          }
        }

        if (!_lodash.default.isEmpty(cds) && !cds[0].minChromeVersion) {
          const {
            version,
            executable
          } = cds[0];
          log.warn(`No known Chromedriver available to automate Chrome version '${chromeVersion}'`);
          log.warn(`Using Chromedriver version '${version}', which has not been tested with Appium`);

          if (!this.storageClient) {
            log.info(autodownloadSuggestion);
          }

          return executable;
        }
      }

      const workingCds = cds.filter(cd => {
        const versionObj = _semver.default.coerce(cd.minChromeVersion);

        return versionObj && chromeVersion.major === versionObj.major;
      });

      if (_lodash.default.isEmpty(workingCds)) {
        if (this.storageClient && !didStorageSync) {
          try {
            if (await syncChromedrivers(chromeVersion)) {
              continue;
            }
          } catch (e) {
            log.warn(`Cannot synchronize local chromedrivers with the remote storage at ${_utils.CD_CDN}: ` + e.message);
            log.debug(e);
          }
        }

        throw new Error(`No Chromedriver found that can automate Chrome '${chromeVersion}'. ` + (!this.storageClient ? `${autodownloadSuggestion}. ` : '') + `See ${CHROMEDRIVER_TUTORIAL} for more details`);
      }

      const binPath = workingCds[0].executable;
      log.debug(`Found ${_appiumSupport.util.pluralize('executable', workingCds.length, true)} ` + `capable of automating Chrome '${chromeVersion}'.\nChoosing the most recent, '${binPath}'.`);
      log.debug('If a specific version is required, specify it with the `chromedriverExecutable`' + 'desired capability.');
      return binPath;
    } while (true);
  }

  async initChromedriverPath() {
    if (this.executableVerified) return;

    if (!this.chromedriver) {
      this.chromedriver = this.useSystemExecutable ? await (0, _utils.getChromedriverBinaryPath)() : await this.getCompatibleChromedriver();
    }

    if (!(await _appiumSupport.fs.exists(this.chromedriver))) {
      throw new Error(`Trying to use a chromedriver binary at the path ` + `${this.chromedriver}, but it doesn't exist!`);
    }

    this.executableVerified = true;
    log.info(`Set chromedriver binary as: ${this.chromedriver}`);
  }

  syncProtocol(cdVersion = null) {
    const coercedVersion = _semver.default.coerce(cdVersion);

    if (!coercedVersion || coercedVersion.major < MIN_CD_VERSION_WITH_W3C_SUPPORT) {
      log.debug(`Chromedriver v. ${cdVersion} does not fully support ${_appiumBaseDriver.PROTOCOLS.W3C} protocol. ` + `Defaulting to ${_appiumBaseDriver.PROTOCOLS.MJSONWP}`);
      return;
    }

    const chromeOptions = (0, _protocolHelpers.getCapValue)(this.capabilities, 'chromeOptions', {});

    if (chromeOptions.w3c === false) {
      log.info(`Chromedriver v. ${cdVersion} supports ${_appiumBaseDriver.PROTOCOLS.W3C} protocol, ` + `but ${_appiumBaseDriver.PROTOCOLS.MJSONWP} one has been explicitly requested`);
      return;
    }

    this.desiredProtocol = _appiumBaseDriver.PROTOCOLS.W3C;
    this.capabilities = (0, _protocolHelpers.toW3cCapNames)(this.capabilities);
  }

  async start(caps, emitStartingState = true) {
    this.capabilities = _lodash.default.cloneDeep(caps);
    this.capabilities.loggingPrefs = _lodash.default.cloneDeep((0, _protocolHelpers.getCapValue)(caps, 'loggingPrefs', {}));

    if (_lodash.default.isEmpty(this.capabilities.loggingPrefs.browser)) {
      this.capabilities.loggingPrefs.browser = 'ALL';
    }

    if (emitStartingState) {
      this.changeState(Chromedriver.STATE_STARTING);
    }

    const args = ['--url-base=wd/hub', `--port=${this.proxyPort}`];

    if (this.adb && this.adb.adbPort) {
      args.push(`--adb-port=${this.adb.adbPort}`);
    }

    if (_lodash.default.isArray(this.cmdArgs)) {
      args.push(...this.cmdArgs);
    }

    if (this.logPath) {
      args.push(`--log-path=${this.logPath}`);
    }

    if (this.disableBuildCheck) {
      args.push('--disable-build-check');
    }

    args.push('--verbose');

    const startDetector = stdout => stdout.startsWith('Starting ');

    let processIsAlive = false;
    let webviewVersion;

    try {
      await this.initChromedriverPath();
      await this.killAll();
      this.proc = new _teen_process.SubProcess(this.chromedriver, args);
      processIsAlive = true;
      this.proc.on('output', (stdout, stderr) => {
        const out = stdout + stderr;
        let match = /"Browser": "(.*)"/.exec(out);

        if (match) {
          webviewVersion = match[1];
          log.debug(`Webview version: '${webviewVersion}'`);
        }

        match = /Starting ChromeDriver ([.\d]+)/.exec(out);

        if (match) {
          log.debug(`Chromedriver version: '${match[1]}'`);
          this.syncProtocol(match[1]);
        }

        if (this.verbose) {
          for (let line of (stdout || '').trim().split('\n')) {
            if (!line.trim().length) continue;
            log.debug(`[STDOUT] ${line}`);
          }

          for (let line of (stderr || '').trim().split('\n')) {
            if (!line.trim().length) continue;
            log.error(`[STDERR] ${line}`);
          }
        }
      });
      this.proc.on('exit', (code, signal) => {
        processIsAlive = false;

        if (this.state !== Chromedriver.STATE_STOPPED && this.state !== Chromedriver.STATE_STOPPING && this.state !== Chromedriver.STATE_RESTARTING) {
          let msg = `Chromedriver exited unexpectedly with code ${code}, ` + `signal ${signal}`;
          log.error(msg);
          this.changeState(Chromedriver.STATE_STOPPED);
        }
      });
      log.info(`Spawning chromedriver with: ${this.chromedriver} ` + `${args.join(' ')}`);
      await this.proc.start(startDetector);
      await this.waitForOnline();
      await this.startSession();
    } catch (e) {
      log.debug(e);
      this.emit(Chromedriver.EVENT_ERROR, e);

      if (processIsAlive) {
        await this.proc.stop();
      }

      let message = '';

      if (e.message.includes('Chrome version must be')) {
        message += 'Unable to automate Chrome version because it is too old for this version of Chromedriver.\n';

        if (webviewVersion) {
          message += `Chrome version on the device: ${webviewVersion}\n`;
        }

        message += `Visit '${CHROMEDRIVER_TUTORIAL}' to troubleshoot the problem.\n`;
      }

      message += e.message;
      log.errorAndThrow(message);
    }
  }

  sessionId() {
    if (this.state !== Chromedriver.STATE_ONLINE) {
      return null;
    }

    return this.jwproxy.sessionId;
  }

  async restart() {
    log.info('Restarting chromedriver');

    if (this.state !== Chromedriver.STATE_ONLINE) {
      throw new Error("Can't restart when we're not online");
    }

    this.changeState(Chromedriver.STATE_RESTARTING);
    await this.stop(false);
    await this.start(this.capabilities, false);
  }

  async waitForOnline() {
    let chromedriverStopped = false;
    await (0, _asyncbox.retryInterval)(20, 200, async () => {
      if (this.state === Chromedriver.STATE_STOPPED) {
        chromedriverStopped = true;
        return;
      }

      await this.getStatus();
    });

    if (chromedriverStopped) {
      throw new Error('ChromeDriver crashed during startup.');
    }
  }

  async getStatus() {
    return await this.jwproxy.command('/status', 'GET');
  }

  async startSession() {
    const sessionCaps = this.desiredProtocol === _appiumBaseDriver.PROTOCOLS.W3C ? {
      capabilities: {
        alwaysMatch: this.capabilities
      }
    } : {
      desiredCapabilities: this.capabilities
    };
    log.info(`Starting ${this.desiredProtocol} Chromedriver session with capabilities: ` + JSON.stringify(sessionCaps, null, 2));
    await this.jwproxy.command('/session', 'POST', sessionCaps);
    this.changeState(Chromedriver.STATE_ONLINE);
  }

  async stop(emitStates = true) {
    if (emitStates) {
      this.changeState(Chromedriver.STATE_STOPPING);
    }

    try {
      await this.jwproxy.command('', 'DELETE');
      await this.proc.stop('SIGTERM', 20000);

      if (emitStates) {
        this.changeState(Chromedriver.STATE_STOPPED);
      }
    } catch (e) {
      log.error(e);
    }
  }

  changeState(state) {
    this.state = state;
    log.debug(`Changed state to '${state}'`);
    this.emit(Chromedriver.EVENT_CHANGED, {
      state
    });
  }

  async sendCommand(url, method, body) {
    return await this.jwproxy.command(url, method, body);
  }

  async proxyReq(req, res) {
    return await this.jwproxy.proxyReqRes(req, res);
  }

  async killAll() {
    let cmd = _appiumSupport.system.isWindows() ? `wmic process where "commandline like '%chromedriver.exe%--port=${this.proxyPort}%'" delete` : `pkill -15 -f "${this.chromedriver}.*--port=${this.proxyPort}"`;
    log.debug(`Killing any old chromedrivers, running: ${cmd}`);

    try {
      await _bluebird.default.promisify(_child_process.default.exec)(cmd);
      log.debug('Successfully cleaned up old chromedrivers');
    } catch (err) {
      log.warn('No old chromedrivers seem to exist');
    }

    if (this.adb) {
      log.debug(`Cleaning any old adb forwarded port socket connections`);

      try {
        for (let conn of await this.adb.getForwardList()) {
          if (conn.indexOf('webview_devtools') !== -1) {
            let params = conn.split(/\s+/);

            if (params.length > 1) {
              await this.adb.removePortForward(params[1].replace(/[\D]*/, ''));
            }
          }
        }
      } catch (err) {
        log.warn(`Unable to clean forwarded ports. Error: '${err.message}'. Continuing.`);
      }
    }
  }

  async hasWorkingWebview() {
    try {
      await this.jwproxy.command('/url', 'GET');
      return true;
    } catch (e) {
      return false;
    }
  }

}

exports.Chromedriver = Chromedriver;
Chromedriver.EVENT_ERROR = 'chromedriver_error';
Chromedriver.EVENT_CHANGED = 'stateChanged';
Chromedriver.STATE_STOPPED = 'stopped';
Chromedriver.STATE_STARTING = 'starting';
Chromedriver.STATE_ONLINE = 'online';
Chromedriver.STATE_STOPPING = 'stopping';
Chromedriver.STATE_RESTARTING = 'restarting';
var _default = Chromedriver;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jaHJvbWVkcml2ZXIuanMiXSwibmFtZXMiOlsibG9nIiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiTkVXX0NEX1ZFUlNJT05fRk9STUFUX01BSk9SX1ZFUlNJT04iLCJERUZBVUxUX0hPU1QiLCJNSU5fQ0RfVkVSU0lPTl9XSVRIX1czQ19TVVBQT1JUIiwiREVGQVVMVF9QT1JUIiwiQ0hST01FX0JVTkRMRV9JRCIsIldFQlZJRVdfU0hFTExfQlVORExFX0lEIiwiV0VCVklFV19CVU5ETEVfSURTIiwiQ0hST01FRFJJVkVSX1RVVE9SSUFMIiwiVkVSU0lPTl9QQVRURVJOIiwiQ0RfVkVSU0lPTl9USU1FT1VUIiwiQ2hyb21lZHJpdmVyIiwiZXZlbnRzIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJhcmdzIiwiaG9zdCIsInBvcnQiLCJ1c2VTeXN0ZW1FeGVjdXRhYmxlIiwiZXhlY3V0YWJsZSIsImV4ZWN1dGFibGVEaXIiLCJidW5kbGVJZCIsIm1hcHBpbmdQYXRoIiwiY21kQXJncyIsImFkYiIsInZlcmJvc2UiLCJsb2dQYXRoIiwiZGlzYWJsZUJ1aWxkQ2hlY2siLCJkZXRhaWxzIiwiaXNBdXRvZG93bmxvYWRFbmFibGVkIiwicHJveHlIb3N0IiwicHJveHlQb3J0IiwicHJvYyIsImNocm9tZWRyaXZlciIsImV4ZWN1dGFibGVWZXJpZmllZCIsInN0YXRlIiwiU1RBVEVfU1RPUFBFRCIsImp3cHJveHkiLCJKV1Byb3h5Iiwic2VydmVyIiwic3RvcmFnZUNsaWVudCIsIkNocm9tZWRyaXZlclN0b3JhZ2VDbGllbnQiLCJjaHJvbWVkcml2ZXJEaXIiLCJjYXBhYmlsaXRpZXMiLCJkZXNpcmVkUHJvdG9jb2wiLCJQUk9UT0NPTFMiLCJNSlNPTldQIiwiZ2V0TWFwcGluZyIsIm1hcHBpbmciLCJfIiwiY2xvbmVEZWVwIiwiQ0hST01FRFJJVkVSX0NIUk9NRV9NQVBQSU5HIiwiZGVidWciLCJmcyIsImV4aXN0cyIsIndhcm4iLCJKU09OIiwicGFyc2UiLCJyZWFkRmlsZSIsImVyciIsImVycm9yIiwibWVzc2FnZSIsImNkVmVyc2lvbiIsImNocm9tZVZlcnNpb24iLCJ0b1BhaXJzIiwiY29lcmNlZFZlcnNpb24iLCJzZW12ZXIiLCJjb2VyY2UiLCJ2ZXJzaW9uIiwiaW5mbyIsImdldENocm9tZWRyaXZlcnMiLCJleGVjdXRhYmxlcyIsImdsb2IiLCJ1dGlsIiwicGx1cmFsaXplIiwibGVuZ3RoIiwiY2RzIiwibWFwQ2hyb21lZHJpdmVyIiwibG9nRXJyb3IiLCJzdGRvdXQiLCJzdGRlcnIiLCJlcnJNc2ciLCJwYXRoIiwiYmFzZW5hbWUiLCJ0aW1lb3V0IiwiaW5jbHVkZXMiLCJtYXRjaCIsImV4ZWMiLCJtaW5DaHJvbWVWZXJzaW9uIiwibWFqb3IiLCJtaW5vciIsImZpbHRlciIsImNkIiwic29ydCIsImEiLCJiIiwiaXNFbXB0eSIsImdldENocm9tZVZlcnNpb24iLCJCcm93c2VyIiwidmVyc2lvbk1hdGNoIiwiYXBpTGV2ZWwiLCJnZXRBcGlMZXZlbCIsImdldENvbXBhdGlibGVDaHJvbWVkcml2ZXIiLCJkaWRTdG9yYWdlU3luYyIsInN5bmNDaHJvbWVkcml2ZXJzIiwicmV0cmlldmVkTWFwcGluZyIsInJldHJpZXZlTWFwcGluZyIsInN0cmluZ2lmeSIsImRyaXZlcktleXMiLCJzeW5jRHJpdmVycyIsIm1pbkJyb3dzZXJWZXJzaW9uIiwic3luY2hyb25pemVkRHJpdmVyc01hcHBpbmciLCJyZWR1Y2UiLCJhY2MiLCJ4IiwiT2JqZWN0IiwiYXNzaWduIiwic2hvdWxkVXBkYXRlU3RhdGljTWFwcGluZyIsIndyaXRlRmlsZSIsImUiLCJlcnJvckFuZFRocm93IiwidmFsdWVzIiwiYXV0b2Rvd25sb2FkU3VnZ2VzdGlvbiIsIkNEX0NETiIsIndvcmtpbmdDZHMiLCJ2ZXJzaW9uT2JqIiwiRXJyb3IiLCJiaW5QYXRoIiwiaW5pdENocm9tZWRyaXZlclBhdGgiLCJzeW5jUHJvdG9jb2wiLCJXM0MiLCJjaHJvbWVPcHRpb25zIiwidzNjIiwic3RhcnQiLCJjYXBzIiwiZW1pdFN0YXJ0aW5nU3RhdGUiLCJsb2dnaW5nUHJlZnMiLCJicm93c2VyIiwiY2hhbmdlU3RhdGUiLCJTVEFURV9TVEFSVElORyIsImFkYlBvcnQiLCJwdXNoIiwiaXNBcnJheSIsInN0YXJ0RGV0ZWN0b3IiLCJzdGFydHNXaXRoIiwicHJvY2Vzc0lzQWxpdmUiLCJ3ZWJ2aWV3VmVyc2lvbiIsImtpbGxBbGwiLCJTdWJQcm9jZXNzIiwib24iLCJvdXQiLCJsaW5lIiwidHJpbSIsInNwbGl0IiwiY29kZSIsInNpZ25hbCIsIlNUQVRFX1NUT1BQSU5HIiwiU1RBVEVfUkVTVEFSVElORyIsIm1zZyIsImpvaW4iLCJ3YWl0Rm9yT25saW5lIiwic3RhcnRTZXNzaW9uIiwiZW1pdCIsIkVWRU5UX0VSUk9SIiwic3RvcCIsInNlc3Npb25JZCIsIlNUQVRFX09OTElORSIsInJlc3RhcnQiLCJjaHJvbWVkcml2ZXJTdG9wcGVkIiwiZ2V0U3RhdHVzIiwiY29tbWFuZCIsInNlc3Npb25DYXBzIiwiYWx3YXlzTWF0Y2giLCJkZXNpcmVkQ2FwYWJpbGl0aWVzIiwiZW1pdFN0YXRlcyIsIkVWRU5UX0NIQU5HRUQiLCJzZW5kQ29tbWFuZCIsInVybCIsIm1ldGhvZCIsImJvZHkiLCJwcm94eVJlcSIsInJlcSIsInJlcyIsInByb3h5UmVxUmVzIiwiY21kIiwic3lzdGVtIiwiaXNXaW5kb3dzIiwiQiIsInByb21pc2lmeSIsImNwIiwiY29ubiIsImdldEZvcndhcmRMaXN0IiwiaW5kZXhPZiIsInBhcmFtcyIsInJlbW92ZVBvcnRGb3J3YXJkIiwicmVwbGFjZSIsImhhc1dvcmtpbmdXZWJ2aWV3Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUlBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLE1BQU1BLEdBQUcsR0FBR0Msc0JBQU9DLFNBQVAsQ0FBaUIsY0FBakIsQ0FBWjs7QUFFQSxNQUFN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QUFRLGdCQUFqRTtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxRQUFNdUksaUJBQU4sR0FBMkI7QUFHekIsUUFBSTtBQUNGLFlBQU0sS0FBSy9KLE9BQUwsQ0FBYXFJLE9BQWIsQ0FBcUIsTUFBckIsRUFBNkIsS0FBN0IsQ0FBTjtBQUNBLGFBQU8sSUFBUDtBQUNELEtBSEQsQ0FHRSxPQUFPbkQsQ0FBUCxFQUFVO0FBQ1YsYUFBTyxLQUFQO0FBQ0Q7QUFDRjs7QUF2bUI0Qzs7O0FBMG1CL0M1RyxZQUFZLENBQUN3SixXQUFiLEdBQTJCLG9CQUEzQjtBQUNBeEosWUFBWSxDQUFDb0ssYUFBYixHQUE2QixjQUE3QjtBQUNBcEssWUFBWSxDQUFDeUIsYUFBYixHQUE2QixTQUE3QjtBQUNBekIsWUFBWSxDQUFDZ0ksY0FBYixHQUE4QixVQUE5QjtBQUNBaEksWUFBWSxDQUFDMkosWUFBYixHQUE0QixRQUE1QjtBQUNBM0osWUFBWSxDQUFDaUosY0FBYixHQUE4QixVQUE5QjtBQUNBakosWUFBWSxDQUFDa0osZ0JBQWIsR0FBZ0MsWUFBaEM7ZUFHZWxKLFkiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc3BpbGU6bWFpblxuXG5pbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBKV1Byb3h5LCBQUk9UT0NPTFMgfSBmcm9tICdhcHBpdW0tYmFzZS1kcml2ZXInO1xuaW1wb3J0IGNwIGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgc3lzdGVtLCBmcywgbG9nZ2VyLCB1dGlsIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHsgcmV0cnlJbnRlcnZhbCwgYXN5bmNtYXAgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyBTdWJQcm9jZXNzLCBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7XG4gIGdldENocm9tZVZlcnNpb24sIGdldENocm9tZWRyaXZlckRpciwgQ0hST01FRFJJVkVSX0NIUk9NRV9NQVBQSU5HLFxuICBnZXRDaHJvbWVkcml2ZXJCaW5hcnlQYXRoLCBDRF9DRE4sXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGNvbXBhcmVWZXJzaW9ucyBmcm9tICdjb21wYXJlLXZlcnNpb25zJztcbmltcG9ydCBDaHJvbWVkcml2ZXJTdG9yYWdlQ2xpZW50IGZyb20gJy4vc3RvcmFnZS1jbGllbnQnO1xuaW1wb3J0IHsgdG9XM2NDYXBOYW1lcywgZ2V0Q2FwVmFsdWUgfSBmcm9tICcuL3Byb3RvY29sLWhlbHBlcnMnO1xuXG5cbmNvbnN0IGxvZyA9IGxvZ2dlci5nZXRMb2dnZXIoJ0Nocm9tZWRyaXZlcicpO1xuXG5jb25zdCBORVdfQ0RfVkVSU0lPTl9GT1JNQVRfTUFKT1JfVkVSU0lPTiA9IDczO1xuY29uc3QgREVGQVVMVF9IT1NUID0gJzEyNy4wLjAuMSc7XG5jb25zdCBNSU5fQ0RfVkVSU0lPTl9XSVRIX1czQ19TVVBQT1JUID0gNzU7XG5jb25zdCBERUZBVUxUX1BPUlQgPSA5NTE1O1xuY29uc3QgQ0hST01FX0JVTkRMRV9JRCA9ICdjb20uYW5kcm9pZC5jaHJvbWUnO1xuY29uc3QgV0VCVklFV19TSEVMTF9CVU5ETEVfSUQgPSAnb3JnLmNocm9taXVtLndlYnZpZXdfc2hlbGwnO1xuY29uc3QgV0VCVklFV19CVU5ETEVfSURTID0gW1xuICAnY29tLmdvb2dsZS5hbmRyb2lkLndlYnZpZXcnLFxuICAnY29tLmFuZHJvaWQud2VidmlldycsXG5dO1xuY29uc3QgQ0hST01FRFJJVkVSX1RVVE9SSUFMID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vYXBwaXVtL2Jsb2IvbWFzdGVyL2RvY3MvZW4vd3JpdGluZy1ydW5uaW5nLWFwcGl1bS93ZWIvY2hyb21lZHJpdmVyLm1kJztcbmNvbnN0IFZFUlNJT05fUEFUVEVSTiA9IC8oW1xcZC5dKykvO1xuXG5jb25zdCBDRF9WRVJTSU9OX1RJTUVPVVQgPSA1MDAwO1xuXG5jbGFzcyBDaHJvbWVkcml2ZXIgZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKGFyZ3MgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb25zdCB7XG4gICAgICBob3N0ID0gREVGQVVMVF9IT1NULFxuICAgICAgcG9ydCA9IERFRkFVTFRfUE9SVCxcbiAgICAgIHVzZVN5c3RlbUV4ZWN1dGFibGUgPSBmYWxzZSxcbiAgICAgIGV4ZWN1dGFibGUsXG4gICAgICBleGVjdXRhYmxlRGlyID0gZ2V0Q2hyb21lZHJpdmVyRGlyKCksXG4gICAgICBidW5kbGVJZCxcbiAgICAgIG1hcHBpbmdQYXRoLFxuICAgICAgY21kQXJncyxcbiAgICAgIGFkYixcbiAgICAgIHZlcmJvc2UsXG4gICAgICBsb2dQYXRoLFxuICAgICAgZGlzYWJsZUJ1aWxkQ2hlY2ssXG4gICAgICBkZXRhaWxzLFxuICAgICAgaXNBdXRvZG93bmxvYWRFbmFibGVkID0gZmFsc2UsXG4gICAgfSA9IGFyZ3M7XG5cbiAgICB0aGlzLnByb3h5SG9zdCA9IGhvc3Q7XG4gICAgdGhpcy5wcm94eVBvcnQgPSBwb3J0O1xuICAgIHRoaXMuYWRiID0gYWRiO1xuICAgIHRoaXMuY21kQXJncyA9IGNtZEFyZ3M7XG4gICAgdGhpcy5wcm9jID0gbnVsbDtcbiAgICB0aGlzLnVzZVN5c3RlbUV4ZWN1dGFibGUgPSB1c2VTeXN0ZW1FeGVjdXRhYmxlO1xuICAgIHRoaXMuY2hyb21lZHJpdmVyID0gZXhlY3V0YWJsZTtcbiAgICB0aGlzLmV4ZWN1dGFibGVEaXIgPSBleGVjdXRhYmxlRGlyO1xuICAgIHRoaXMubWFwcGluZ1BhdGggPSBtYXBwaW5nUGF0aDtcbiAgICB0aGlzLmJ1bmRsZUlkID0gYnVuZGxlSWQ7XG4gICAgdGhpcy5leGVjdXRhYmxlVmVyaWZpZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0gQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQ7XG4gICAgdGhpcy5qd3Byb3h5ID0gbmV3IEpXUHJveHkoe3NlcnZlcjogdGhpcy5wcm94eUhvc3QsIHBvcnQ6IHRoaXMucHJveHlQb3J0fSk7XG4gICAgdGhpcy52ZXJib3NlID0gdmVyYm9zZTtcbiAgICB0aGlzLmxvZ1BhdGggPSBsb2dQYXRoO1xuICAgIHRoaXMuZGlzYWJsZUJ1aWxkQ2hlY2sgPSAhIWRpc2FibGVCdWlsZENoZWNrO1xuICAgIHRoaXMuc3RvcmFnZUNsaWVudCA9IGlzQXV0b2Rvd25sb2FkRW5hYmxlZFxuICAgICAgPyBuZXcgQ2hyb21lZHJpdmVyU3RvcmFnZUNsaWVudCh7IGNocm9tZWRyaXZlckRpcjogdGhpcy5leGVjdXRhYmxlRGlyIH0pXG4gICAgICA6IG51bGw7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB0aGlzLmNhcGFiaWxpdGllcyA9IHt9O1xuICAgIHRoaXMuZGVzaXJlZFByb3RvY29sID0gUFJPVE9DT0xTLk1KU09OV1A7XG4gIH1cblxuICBhc3luYyBnZXRNYXBwaW5nICgpIHtcbiAgICBsZXQgbWFwcGluZyA9IF8uY2xvbmVEZWVwKENIUk9NRURSSVZFUl9DSFJPTUVfTUFQUElORyk7XG4gICAgaWYgKHRoaXMubWFwcGluZ1BhdGgpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgQXR0ZW1wdGluZyB0byB1c2UgQ2hyb21lZHJpdmVyLUNocm9tZSBtYXBwaW5nIGZyb20gJyR7dGhpcy5tYXBwaW5nUGF0aH0nYCk7XG4gICAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyh0aGlzLm1hcHBpbmdQYXRoKSkge1xuICAgICAgICBsb2cud2FybihgTm8gZmlsZSBmb3VuZCBhdCAnJHt0aGlzLm1hcHBpbmdQYXRofScuIFVzaW5nIGRlZmF1bHQgbWFwcGluZ2ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtYXBwaW5nID0gSlNPTi5wYXJzZShhd2FpdCBmcy5yZWFkRmlsZSh0aGlzLm1hcHBpbmdQYXRoLCAndXRmOCcpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nLmVycm9yKGBFcnJvciBwYXJzaW5nIG1hcHBpbmcgZnJvbSAnJHt0aGlzLm1hcHBpbmdQYXRofSc6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgbG9nLndhcm4oJ1VzaW5nIGRlZmF1bHQgbWFwcGluZycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlcyBmb3IgbWluaW11bSBjaHJvbWUgdmVyc2lvbiBhcmUgc2VtdmVyIGNvbXBsaWFudFxuICAgIGZvciAoY29uc3QgW2NkVmVyc2lvbiwgY2hyb21lVmVyc2lvbl0gb2YgXy50b1BhaXJzKG1hcHBpbmcpKSB7XG4gICAgICBjb25zdCBjb2VyY2VkVmVyc2lvbiA9IHNlbXZlci5jb2VyY2UoY2hyb21lVmVyc2lvbik7XG4gICAgICBpZiAoY29lcmNlZFZlcnNpb24pIHtcbiAgICAgICAgbWFwcGluZ1tjZFZlcnNpb25dID0gY29lcmNlZFZlcnNpb24udmVyc2lvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZy5pbmZvKGAnJHtjaHJvbWVWZXJzaW9ufScgaXMgbm90IGEgdmFsaWQgdmVyc2lvbiBudW1iZXIuIFNraXBwaW5nIGl0YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXBwaW5nO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q2hyb21lZHJpdmVycyAobWFwcGluZykge1xuICAgIC8vIGdvIHRocm91Z2ggdGhlIHZlcnNpb25zIGF2YWlsYWJsZVxuICAgIGNvbnN0IGV4ZWN1dGFibGVzID0gYXdhaXQgZnMuZ2xvYihgJHt0aGlzLmV4ZWN1dGFibGVEaXJ9LypgKTtcbiAgICBsb2cuZGVidWcoYEZvdW5kICR7dXRpbC5wbHVyYWxpemUoJ2V4ZWN1dGFibGUnLCBleGVjdXRhYmxlcy5sZW5ndGgsIHRydWUpfSBgICtcbiAgICAgIGBpbiAnJHt0aGlzLmV4ZWN1dGFibGVEaXJ9J2ApO1xuICAgIGNvbnN0IGNkcyA9IChhd2FpdCBhc3luY21hcChleGVjdXRhYmxlcywgYXN5bmMgZnVuY3Rpb24gbWFwQ2hyb21lZHJpdmVyIChleGVjdXRhYmxlKSB7XG4gICAgICBjb25zdCBsb2dFcnJvciA9ICh7bWVzc2FnZSwgc3Rkb3V0ID0gbnVsbCwgc3RkZXJyID0gbnVsbH0pID0+IHtcbiAgICAgICAgbGV0IGVyck1zZyA9IGBDYW5ub3QgcmV0cmlldmUgdmVyc2lvbiBudW1iZXIgZnJvbSAnJHtwYXRoLmJhc2VuYW1lKGV4ZWN1dGFibGUpfScgQ2hyb21lZHJpdmVyIGJpbmFyeS4gYCArXG4gICAgICAgICAgYE1ha2Ugc3VyZSBpdCByZXR1cm5zIGEgdmFsaWQgdmVyc2lvbiBzdHJpbmcgaW4gcmVzcG9uc2UgdG8gJy0tdmVyc2lvbicgY29tbWFuZCBsaW5lIGFyZ3VtZW50LiAke21lc3NhZ2V9YDtcbiAgICAgICAgaWYgKHN0ZG91dCkge1xuICAgICAgICAgIGVyck1zZyArPSBgXFxuU3Rkb3V0OiAke3N0ZG91dH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGRlcnIpIHtcbiAgICAgICAgICBlcnJNc2cgKz0gYFxcblN0ZGVycjogJHtzdGRlcnJ9YDtcbiAgICAgICAgfVxuICAgICAgICBsb2cud2FybihlcnJNc2cpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGxldCBzdGRvdXQ7XG4gICAgICBsZXQgc3RkZXJyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgKHtzdGRvdXQsIHN0ZGVycn0gPSBhd2FpdCBleGVjKGV4ZWN1dGFibGUsIFsnLS12ZXJzaW9uJ10sIHtcbiAgICAgICAgICB0aW1lb3V0OiBDRF9WRVJTSU9OX1RJTUVPVVQsXG4gICAgICAgIH0pKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIShlcnIubWVzc2FnZSB8fCAnJykuaW5jbHVkZXMoJ3RpbWVkIG91dCcpICYmICEoZXJyLnN0ZG91dCB8fCAnJykuaW5jbHVkZXMoJ1N0YXJ0aW5nIENocm9tZURyaXZlcicpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvZ0Vycm9yKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGlzIGhhcyB0aW1lZCBvdXQsIGl0IGhhcyBhY3R1YWxseSBzdGFydGVkIENocm9tZWRyaXZlcixcbiAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB0aGVyZSB3aWxsIGFsc28gYmUgdGhlIHZlcnNpb24gc3RyaW5nIGluIHRoZSBvdXRwdXRcbiAgICAgICAgc3Rkb3V0ID0gZXJyLnN0ZG91dDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF0Y2ggPSAvQ2hyb21lRHJpdmVyXFxzK1xcKD92PyhbXFxkLl0rKVxcKT8vaS5leGVjKHN0ZG91dCk7IC8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvenBqNXdBLzFcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGxvZ0Vycm9yKHttZXNzYWdlOiAnQ2Fubm90IHBhcnNlIHRoZSB2ZXJzaW9uIHN0cmluZycsIHN0ZG91dCwgc3RkZXJyfSk7XG4gICAgICB9XG4gICAgICBsZXQgdmVyc2lvbiA9IG1hdGNoWzFdO1xuICAgICAgbGV0IG1pbkNocm9tZVZlcnNpb24gPSBtYXBwaW5nW3ZlcnNpb25dO1xuICAgICAgY29uc3QgY29lcmNlZFZlcnNpb24gPSBzZW12ZXIuY29lcmNlKHZlcnNpb24pO1xuICAgICAgaWYgKGNvZXJjZWRWZXJzaW9uKSB7XG4gICAgICAgIC8vIGJlZm9yZSAyMDE5LTAzLTA2IHZlcnNpb25zIHdlcmUgb2YgdGhlIGZvcm0gbWFqb3IubWlub3JcbiAgICAgICAgaWYgKGNvZXJjZWRWZXJzaW9uLm1ham9yIDwgTkVXX0NEX1ZFUlNJT05fRk9STUFUX01BSk9SX1ZFUlNJT04pIHtcbiAgICAgICAgICB2ZXJzaW9uID0gYCR7Y29lcmNlZFZlcnNpb24ubWFqb3J9LiR7Y29lcmNlZFZlcnNpb24ubWlub3J9YDtcbiAgICAgICAgICBtaW5DaHJvbWVWZXJzaW9uID0gbWFwcGluZ1t2ZXJzaW9uXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1pbkNocm9tZVZlcnNpb24gJiYgY29lcmNlZFZlcnNpb24ubWFqb3IgPj0gTkVXX0NEX1ZFUlNJT05fRk9STUFUX01BSk9SX1ZFUlNJT04pIHtcbiAgICAgICAgICAvLyBBc3N1bWUgdGhlIG1ham9yIENocm9tZSB2ZXJzaW9uIGlzIHRoZSBzYW1lIGFzIHRoZSBjb3JyZXNwb25kaW5nIGRyaXZlciBtYWpvciB2ZXJzaW9uXG4gICAgICAgICAgbWluQ2hyb21lVmVyc2lvbiA9IGAke2NvZXJjZWRWZXJzaW9uLm1ham9yfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4ZWN1dGFibGUsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIG1pbkNocm9tZVZlcnNpb24sXG4gICAgICB9O1xuICAgIH0pKVxuICAgICAgLmZpbHRlcigoY2QpID0+ICEhY2QpXG4gICAgICAuc29ydCgoYSwgYikgPT4gY29tcGFyZVZlcnNpb25zKGIudmVyc2lvbiwgYS52ZXJzaW9uKSk7XG4gICAgaWYgKF8uaXNFbXB0eShjZHMpKSB7XG4gICAgICBsb2cuaW5mbyhgTm8gQ2hyb21lZHJpdmVycyB3ZXJlIGZvdW5kIGluICcke3RoaXMuZXhlY3V0YWJsZURpcn0nYCk7XG4gICAgICByZXR1cm4gY2RzO1xuICAgIH1cbiAgICBsb2cuZGVidWcoYFRoZSBmb2xsb3dpbmcgQ2hyb21lZHJpdmVyIGV4ZWN1dGFibGVzIHdlcmUgZm91bmQ6YCk7XG4gICAgZm9yIChjb25zdCBjZCBvZiBjZHMpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgICAgICcke2NkLmV4ZWN1dGFibGV9JyAodmVyc2lvbiAnJHtjZC52ZXJzaW9ufScsIG1pbmltdW0gQ2hyb21lIHZlcnNpb24gJyR7Y2QubWluQ2hyb21lVmVyc2lvbiA/IGNkLm1pbkNocm9tZVZlcnNpb24gOiAnVW5rbm93bid9JylgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNkcztcbiAgfVxuXG4gIGFzeW5jIGdldENocm9tZVZlcnNpb24gKCkge1xuICAgIC8vIFRyeSB0byByZXRyaWV2ZSB0aGUgdmVyc2lvbiBmcm9tIGBkZXRhaWxzYCBwcm9wZXJ0eSBpZiBpdCBpcyBzZXRcbiAgICAvLyBUaGUgYGluZm9gIGl0ZW0gbXVzdCBjb250YWluIHRoZSBvdXRwdXQgb2YgL2pzb24vdmVyc2lvbiBDRFAgY29tbWFuZFxuICAgIC8vIHdoZXJlIGBCcm93c2VyYCBmaWVsZCBsb29rcyBsaWtlIGBDaHJvbWUvNzIuMC4zNjAxLjBgYFxuICAgIGlmICh0aGlzLmRldGFpbHM/LmluZm8pIHtcbiAgICAgIGxvZy5kZWJ1ZyhgQnJvd3NlciB2ZXJzaW9uIGluIHRoZSBzdXBwbGllZCBkZXRhaWxzOiAke3RoaXMuZGV0YWlscz8uaW5mbz8uQnJvd3Nlcn1gKTtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbk1hdGNoID0gVkVSU0lPTl9QQVRURVJOLmV4ZWModGhpcy5kZXRhaWxzPy5pbmZvPy5Ccm93c2VyKTtcbiAgICBpZiAodmVyc2lvbk1hdGNoKSB7XG4gICAgICBjb25zdCBjb2VyY2VkVmVyc2lvbiA9IHNlbXZlci5jb2VyY2UodmVyc2lvbk1hdGNoWzFdKTtcbiAgICAgIGlmIChjb2VyY2VkVmVyc2lvbikge1xuICAgICAgICByZXR1cm4gY29lcmNlZFZlcnNpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGNocm9tZVZlcnNpb247XG5cbiAgICAvLyBpbiBjYXNlIG9mIFdlYlZpZXcgQnJvd3NlciBUZXN0ZXIsIHNpbXBseSB0cnkgdG8gZmluZCB0aGUgdW5kZXJseWluZyB3ZWJ2aWV3XG4gICAgaWYgKHRoaXMuYnVuZGxlSWQgPT09IFdFQlZJRVdfU0hFTExfQlVORExFX0lEKSB7XG4gICAgICBmb3IgKGNvbnN0IGJ1bmRsZUlkIG9mIFdFQlZJRVdfQlVORExFX0lEUykge1xuICAgICAgICBjaHJvbWVWZXJzaW9uID0gYXdhaXQgZ2V0Q2hyb21lVmVyc2lvbih0aGlzLmFkYiwgYnVuZGxlSWQpO1xuICAgICAgICBpZiAoY2hyb21lVmVyc2lvbikge1xuICAgICAgICAgIHRoaXMuYnVuZGxlSWQgPSBidW5kbGVJZDtcbiAgICAgICAgICByZXR1cm4gc2VtdmVyLmNvZXJjZShjaHJvbWVWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gb24gQW5kcm9pZCA3LTkgd2Vidmlld3MgYXJlIGJhY2tlZCBieSB0aGUgbWFpbiBDaHJvbWUsIG5vdCB0aGUgc3lzdGVtIHdlYnZpZXdcbiAgICBpZiAodGhpcy5hZGIpIHtcbiAgICAgIGNvbnN0IGFwaUxldmVsID0gYXdhaXQgdGhpcy5hZGIuZ2V0QXBpTGV2ZWwoKTtcbiAgICAgIGlmIChhcGlMZXZlbCA+PSAyNCAmJiBhcGlMZXZlbCA8PSAyOCkge1xuICAgICAgICB0aGlzLmJ1bmRsZUlkID0gQ0hST01FX0JVTkRMRV9JRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0cnkgb3V0IHdlYnZpZXdzIHdoZW4gbm8gYnVuZGxlIGlkIGlzIHNlbnQgaW5cbiAgICBpZiAoIXRoaXMuYnVuZGxlSWQpIHtcbiAgICAgIC8vIGRlZmF1bHQgdG8gdGhlIGdlbmVyaWMgQ2hyb21lIGJ1bmRsZVxuICAgICAgdGhpcy5idW5kbGVJZCA9IENIUk9NRV9CVU5ETEVfSUQ7XG5cbiAgICAgIC8vIHdlIGhhdmUgYSB3ZWJ2aWV3IG9mIHNvbWUgc29ydCwgc28gdHJ5IHRvIGZpbmQgdGhlIGJ1bmRsZSB2ZXJzaW9uXG4gICAgICBmb3IgKGNvbnN0IGJ1bmRsZUlkIG9mIFdFQlZJRVdfQlVORExFX0lEUykge1xuICAgICAgICBjaHJvbWVWZXJzaW9uID0gYXdhaXQgZ2V0Q2hyb21lVmVyc2lvbih0aGlzLmFkYiwgYnVuZGxlSWQpO1xuICAgICAgICBpZiAoY2hyb21lVmVyc2lvbikge1xuICAgICAgICAgIHRoaXMuYnVuZGxlSWQgPSBidW5kbGVJZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGRvIG5vdCBoYXZlIGEgY2hyb21lIHZlcnNpb24sIGl0IG11c3Qgbm90IGJlIGEgd2Vidmlld1xuICAgIGlmICghY2hyb21lVmVyc2lvbikge1xuICAgICAgY2hyb21lVmVyc2lvbiA9IGF3YWl0IGdldENocm9tZVZlcnNpb24odGhpcy5hZGIsIHRoaXMuYnVuZGxlSWQpO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSBpdCBpcyBzZW12ZXIsIHNvIGxhdGVyIGNoZWNrcyB3b24ndCBmYWlsXG4gICAgcmV0dXJuIGNocm9tZVZlcnNpb24gPyBzZW12ZXIuY29lcmNlKGNocm9tZVZlcnNpb24pIDogbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGdldENvbXBhdGlibGVDaHJvbWVkcml2ZXIgKCkge1xuICAgIGlmICghdGhpcy5hZGIpIHtcbiAgICAgIHJldHVybiBhd2FpdCBnZXRDaHJvbWVkcml2ZXJCaW5hcnlQYXRoKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWFwcGluZyA9IGF3YWl0IHRoaXMuZ2V0TWFwcGluZygpO1xuICAgIGxldCBkaWRTdG9yYWdlU3luYyA9IGZhbHNlO1xuICAgIGNvbnN0IHN5bmNDaHJvbWVkcml2ZXJzID0gYXN5bmMgKGNocm9tZVZlcnNpb24pID0+IHtcbiAgICAgIGRpZFN0b3JhZ2VTeW5jID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHJldHJpZXZlZE1hcHBpbmcgPSBhd2FpdCB0aGlzLnN0b3JhZ2VDbGllbnQucmV0cmlldmVNYXBwaW5nKCk7XG4gICAgICBsb2cuZGVidWcoJ0dvdCBjaHJvbWVkcml2ZXJzIG1hcHBpbmcgZnJvbSB0aGUgc3RvcmFnZTogJyArXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHJldHJpZXZlZE1hcHBpbmcsIG51bGwsIDIpKTtcbiAgICAgIGNvbnN0IGRyaXZlcktleXMgPSBhd2FpdCB0aGlzLnN0b3JhZ2VDbGllbnQuc3luY0RyaXZlcnMoe1xuICAgICAgICBtaW5Ccm93c2VyVmVyc2lvbjogY2hyb21lVmVyc2lvbi5tYWpvcixcbiAgICAgIH0pO1xuICAgICAgaWYgKF8uaXNFbXB0eShkcml2ZXJLZXlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzeW5jaHJvbml6ZWREcml2ZXJzTWFwcGluZyA9IGRyaXZlcktleXMucmVkdWNlKChhY2MsIHgpID0+IHtcbiAgICAgICAgY29uc3Qge3ZlcnNpb24sIG1pbkJyb3dzZXJWZXJzaW9ufSA9IHJldHJpZXZlZE1hcHBpbmdbeF07XG4gICAgICAgIGFjY1t2ZXJzaW9uXSA9IG1pbkJyb3dzZXJWZXJzaW9uO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgICAgT2JqZWN0LmFzc2lnbihtYXBwaW5nLCBzeW5jaHJvbml6ZWREcml2ZXJzTWFwcGluZyk7XG4gICAgICBsZXQgc2hvdWxkVXBkYXRlU3RhdGljTWFwcGluZyA9IHRydWU7XG4gICAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKHRoaXMubWFwcGluZ1BhdGgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHRoaXMubWFwcGluZ1BhdGgsIEpTT04uc3RyaW5naWZ5KG1hcHBpbmcsIG51bGwsIDIpLCAndXRmOCcpO1xuICAgICAgICAgIHNob3VsZFVwZGF0ZVN0YXRpY01hcHBpbmcgPSBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZy53YXJuKGBDYW5ub3Qgc3RvcmUgdGhlIHVwZGF0ZWQgY2hyb21lZHJpdmVycyBtYXBwaW5nIGludG8gJyR7dGhpcy5tYXBwaW5nUGF0aH0nLiBgICtcbiAgICAgICAgICAgIGBUaGlzIG1heSByZWR1Y2UgdGhlIHBlcmZvcm1hbmNlIG9mIGZ1cnRoZXIgZXhlY3V0aW9ucy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlU3RhdGljTWFwcGluZykge1xuICAgICAgICBPYmplY3QuYXNzaWduKENIUk9NRURSSVZFUl9DSFJPTUVfTUFQUElORywgbWFwcGluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgY2RzID0gYXdhaXQgdGhpcy5nZXRDaHJvbWVkcml2ZXJzKG1hcHBpbmcpO1xuXG4gICAgICBpZiAodGhpcy5kaXNhYmxlQnVpbGRDaGVjaykge1xuICAgICAgICBpZiAoXy5pc0VtcHR5KGNkcykpIHtcbiAgICAgICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBvbmUgQ2hyb21lZHJpdmVyIGV4ZWN1dGFibGUgYXZhaWxhYmxlIGZvciB1c2UgaWYgYCArXG4gICAgICAgICAgICBgJ2Nocm9tZWRyaXZlckRpc2FibGVCdWlsZENoZWNrJyBjYXBhYmlsaXR5IGlzIHNldCB0byAndHJ1ZSdgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7dmVyc2lvbiwgZXhlY3V0YWJsZX0gPSBjZHNbMF07XG4gICAgICAgIGxvZy53YXJuKGBDaHJvbWUgYnVpbGQgY2hlY2sgZGlzYWJsZWQuIFVzaW5nIG1vc3QgcmVjZW50IENocm9tZWRyaXZlciB2ZXJzaW9uICgke3ZlcnNpb259LCBhdCAnJHtleGVjdXRhYmxlfScpYCk7XG4gICAgICAgIGxvZy53YXJuKGBJZiB0aGlzIGlzIHdyb25nLCBzZXQgJ2Nocm9tZWRyaXZlckRpc2FibGVCdWlsZENoZWNrJyBjYXBhYmlsaXR5IHRvICdmYWxzZSdgKTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGFibGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNocm9tZVZlcnNpb24gPSBhd2FpdCB0aGlzLmdldENocm9tZVZlcnNpb24oKTtcbiAgICAgIGlmICghY2hyb21lVmVyc2lvbikge1xuICAgICAgICAvLyB1bmFibGUgdG8gZ2V0IHRoZSBjaHJvbWUgdmVyc2lvblxuICAgICAgICBpZiAoXy5pc0VtcHR5KGNkcykpIHtcbiAgICAgICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBvbmUgQ2hyb21lZHJpdmVyIGV4ZWN1dGFibGUgYXZhaWxhYmxlIGZvciB1c2UgaWYgYCArXG4gICAgICAgICAgICBgdGhlIGN1cnJlbnQgQ2hyb21lIHZlcnNpb24gY2Fubm90IGJlIGRldGVybWluZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7dmVyc2lvbiwgZXhlY3V0YWJsZX0gPSBjZHNbMF07XG4gICAgICAgIGxvZy53YXJuKGBVbmFibGUgdG8gZGlzY292ZXIgQ2hyb21lIHZlcnNpb24uIFVzaW5nIENocm9tZWRyaXZlciAke3ZlcnNpb259IGF0ICcke2V4ZWN1dGFibGV9J2ApO1xuICAgICAgICByZXR1cm4gZXhlY3V0YWJsZTtcbiAgICAgIH1cblxuICAgICAgbG9nLmRlYnVnKGBGb3VuZCBDaHJvbWUgYnVuZGxlICcke3RoaXMuYnVuZGxlSWR9JyB2ZXJzaW9uICcke2Nocm9tZVZlcnNpb259J2ApO1xuICAgICAgaWYgKCFfLmlzRW1wdHkobWFwcGluZykpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBUaGUgbW9zdCByZWNlbnQga25vd24gQ2hyb21lIHZlcnNpb246ICR7Xy52YWx1ZXMobWFwcGluZylbMF19YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF1dG9kb3dubG9hZFN1Z2dlc3Rpb24gPVxuICAgICAgICAnWW91IGNvdWxkIGFsc28gdHJ5IHRvIGVuYWJsZSBhdXRvbWF0ZWQgY2hyb21lZHJpdmVycyBkb3dubG9hZCBzZXJ2ZXIgZmVhdHVyZSc7XG4gICAgICBpZiAoXy5pc0VtcHR5KG1hcHBpbmcpIHx8IGNocm9tZVZlcnNpb24ubWFqb3IgPiAoc2VtdmVyLmNvZXJjZShfLnZhbHVlcyhtYXBwaW5nKVswXSkpPy5tYWpvcikge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlQ2xpZW50ICYmICFkaWRTdG9yYWdlU3luYykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgc3luY0Nocm9tZWRyaXZlcnMoY2hyb21lVmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nLndhcm4oYENhbm5vdCBzeW5jaHJvbml6ZSBsb2NhbCBjaHJvbWVkcml2ZXJzIHdpdGggdGhlIHJlbW90ZSBzdG9yYWdlIGF0ICR7Q0RfQ0ROfTogYCArXG4gICAgICAgICAgICAgIGUubWVzc2FnZSk7XG4gICAgICAgICAgICBsb2cuZGVidWcoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgYSBjaHJvbWUgYWJvdmUgdGhlIGxhdGVzdCB2ZXJzaW9uIHdlIGtub3cgYWJvdXQsXG4gICAgICAgIC8vIGFuZCB3ZSBoYXZlIGEgY2hyb21lZHJpdmVyIHRoYXQgaXMgYmV5b25kIHdoYXQgd2Uga25vdyxcbiAgICAgICAgLy8gc28gdXNlZSB0aGUgbW9zdCByZWNlbnQgY2hyb21lZHJpdmVyIHRoYXQgd2UgZm91bmRcbiAgICAgICAgaWYgKCFfLmlzRW1wdHkoY2RzKSAmJiAhY2RzWzBdLm1pbkNocm9tZVZlcnNpb24pIHtcbiAgICAgICAgICBjb25zdCB7dmVyc2lvbiwgZXhlY3V0YWJsZX0gPSBjZHNbMF07XG4gICAgICAgICAgbG9nLndhcm4oYE5vIGtub3duIENocm9tZWRyaXZlciBhdmFpbGFibGUgdG8gYXV0b21hdGUgQ2hyb21lIHZlcnNpb24gJyR7Y2hyb21lVmVyc2lvbn0nYCk7XG4gICAgICAgICAgbG9nLndhcm4oYFVzaW5nIENocm9tZWRyaXZlciB2ZXJzaW9uICcke3ZlcnNpb259Jywgd2hpY2ggaGFzIG5vdCBiZWVuIHRlc3RlZCB3aXRoIEFwcGl1bWApO1xuICAgICAgICAgIGlmICghdGhpcy5zdG9yYWdlQ2xpZW50KSB7XG4gICAgICAgICAgICBsb2cuaW5mbyhhdXRvZG93bmxvYWRTdWdnZXN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV4ZWN1dGFibGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgd29ya2luZ0NkcyA9IGNkcy5maWx0ZXIoKGNkKSA9PiB7XG4gICAgICAgIGNvbnN0IHZlcnNpb25PYmogPSBzZW12ZXIuY29lcmNlKGNkLm1pbkNocm9tZVZlcnNpb24pO1xuICAgICAgICByZXR1cm4gdmVyc2lvbk9iaiAmJiBjaHJvbWVWZXJzaW9uLm1ham9yID09PSB2ZXJzaW9uT2JqLm1ham9yO1xuICAgICAgfSk7XG4gICAgICBpZiAoXy5pc0VtcHR5KHdvcmtpbmdDZHMpKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3JhZ2VDbGllbnQgJiYgIWRpZFN0b3JhZ2VTeW5jKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChhd2FpdCBzeW5jQ2hyb21lZHJpdmVycyhjaHJvbWVWZXJzaW9uKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2cud2FybihgQ2Fubm90IHN5bmNocm9uaXplIGxvY2FsIGNocm9tZWRyaXZlcnMgd2l0aCB0aGUgcmVtb3RlIHN0b3JhZ2UgYXQgJHtDRF9DRE59OiBgICtcbiAgICAgICAgICAgICAgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBDaHJvbWVkcml2ZXIgZm91bmQgdGhhdCBjYW4gYXV0b21hdGUgQ2hyb21lICcke2Nocm9tZVZlcnNpb259Jy4gYCArXG4gICAgICAgICAgKCF0aGlzLnN0b3JhZ2VDbGllbnQgPyBgJHthdXRvZG93bmxvYWRTdWdnZXN0aW9ufS4gYCA6ICcnKSArXG4gICAgICAgICAgYFNlZSAke0NIUk9NRURSSVZFUl9UVVRPUklBTH0gZm9yIG1vcmUgZGV0YWlsc2ApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiaW5QYXRoID0gd29ya2luZ0Nkc1swXS5leGVjdXRhYmxlO1xuICAgICAgbG9nLmRlYnVnKGBGb3VuZCAke3V0aWwucGx1cmFsaXplKCdleGVjdXRhYmxlJywgd29ya2luZ0Nkcy5sZW5ndGgsIHRydWUpfSBgICtcbiAgICAgICAgYGNhcGFibGUgb2YgYXV0b21hdGluZyBDaHJvbWUgJyR7Y2hyb21lVmVyc2lvbn0nLlxcbkNob29zaW5nIHRoZSBtb3N0IHJlY2VudCwgJyR7YmluUGF0aH0nLmApO1xuICAgICAgbG9nLmRlYnVnKCdJZiBhIHNwZWNpZmljIHZlcnNpb24gaXMgcmVxdWlyZWQsIHNwZWNpZnkgaXQgd2l0aCB0aGUgYGNocm9tZWRyaXZlckV4ZWN1dGFibGVgJyArXG4gICAgICAgICdkZXNpcmVkIGNhcGFiaWxpdHkuJyk7XG4gICAgICByZXR1cm4gYmluUGF0aDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgfSB3aGlsZSAodHJ1ZSk7XG4gIH1cblxuICBhc3luYyBpbml0Q2hyb21lZHJpdmVyUGF0aCAoKSB7XG4gICAgaWYgKHRoaXMuZXhlY3V0YWJsZVZlcmlmaWVkKSByZXR1cm47IC8vZXNsaW50LWRpc2FibGUtbGluZSBjdXJseVxuXG4gICAgLy8gdGhlIGV4ZWN1dGFibGUgbWlnaHQgYmUgc2V0IChpZiBwYXNzZWQgaW4pXG4gICAgLy8gb3Igd2UgbWlnaHQgd2FudCB0byB1c2UgdGhlIGJhc2ljIG9uZSBpbnN0YWxsZWQgd2l0aCB0aGlzIGRyaXZlclxuICAgIC8vIG9yIHdlIHdhbnQgdG8gZmlndXJlIG91dCB0aGUgYmVzdCBvbmVcbiAgICBpZiAoIXRoaXMuY2hyb21lZHJpdmVyKSB7XG4gICAgICB0aGlzLmNocm9tZWRyaXZlciA9IHRoaXMudXNlU3lzdGVtRXhlY3V0YWJsZVxuICAgICAgICA/IGF3YWl0IGdldENocm9tZWRyaXZlckJpbmFyeVBhdGgoKVxuICAgICAgICA6IGF3YWl0IHRoaXMuZ2V0Q29tcGF0aWJsZUNocm9tZWRyaXZlcigpO1xuICAgIH1cblxuICAgIGlmICghYXdhaXQgZnMuZXhpc3RzKHRoaXMuY2hyb21lZHJpdmVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcnlpbmcgdG8gdXNlIGEgY2hyb21lZHJpdmVyIGJpbmFyeSBhdCB0aGUgcGF0aCBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLmNocm9tZWRyaXZlcn0sIGJ1dCBpdCBkb2Vzbid0IGV4aXN0IWApO1xuICAgIH1cbiAgICB0aGlzLmV4ZWN1dGFibGVWZXJpZmllZCA9IHRydWU7XG4gICAgbG9nLmluZm8oYFNldCBjaHJvbWVkcml2ZXIgYmluYXJ5IGFzOiAke3RoaXMuY2hyb21lZHJpdmVyfWApO1xuICB9XG5cbiAgc3luY1Byb3RvY29sIChjZFZlcnNpb24gPSBudWxsKSB7XG4gICAgY29uc3QgY29lcmNlZFZlcnNpb24gPSBzZW12ZXIuY29lcmNlKGNkVmVyc2lvbik7XG4gICAgaWYgKCFjb2VyY2VkVmVyc2lvbiB8fCBjb2VyY2VkVmVyc2lvbi5tYWpvciA8IE1JTl9DRF9WRVJTSU9OX1dJVEhfVzNDX1NVUFBPUlQpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgQ2hyb21lZHJpdmVyIHYuICR7Y2RWZXJzaW9ufSBkb2VzIG5vdCBmdWxseSBzdXBwb3J0ICR7UFJPVE9DT0xTLlczQ30gcHJvdG9jb2wuIGAgK1xuICAgICAgICBgRGVmYXVsdGluZyB0byAke1BST1RPQ09MUy5NSlNPTldQfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaHJvbWVPcHRpb25zID0gZ2V0Q2FwVmFsdWUodGhpcy5jYXBhYmlsaXRpZXMsICdjaHJvbWVPcHRpb25zJywge30pO1xuICAgIGlmIChjaHJvbWVPcHRpb25zLnczYyA9PT0gZmFsc2UpIHtcbiAgICAgIGxvZy5pbmZvKGBDaHJvbWVkcml2ZXIgdi4gJHtjZFZlcnNpb259IHN1cHBvcnRzICR7UFJPVE9DT0xTLlczQ30gcHJvdG9jb2wsIGAgK1xuICAgICAgICBgYnV0ICR7UFJPVE9DT0xTLk1KU09OV1B9IG9uZSBoYXMgYmVlbiBleHBsaWNpdGx5IHJlcXVlc3RlZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlc2lyZWRQcm90b2NvbCA9IFBST1RPQ09MUy5XM0M7XG4gICAgLy8gZ2l2ZW4gY2FwcyBtaWdodCBub3QgYmUgcHJvcGVybHkgcHJlZml4ZWRcbiAgICAvLyBzbyB3ZSB0cnkgdG8gZml4IHRoZW0gaW4gb3JkZXIgdG8gcHJvcGVybHkgaW5pdFxuICAgIC8vIHRoZSBuZXcgVzNDIHNlc3Npb25cbiAgICB0aGlzLmNhcGFiaWxpdGllcyA9IHRvVzNjQ2FwTmFtZXModGhpcy5jYXBhYmlsaXRpZXMpO1xuICB9XG5cbiAgYXN5bmMgc3RhcnQgKGNhcHMsIGVtaXRTdGFydGluZ1N0YXRlID0gdHJ1ZSkge1xuICAgIHRoaXMuY2FwYWJpbGl0aWVzID0gXy5jbG9uZURlZXAoY2Fwcyk7XG5cbiAgICAvLyBzZXQgdGhlIGxvZ2dpbmcgcHJlZmVyZW5jZXMgdG8gQUxMIHRoZSBjb25zb2xlIGxvZ3NcbiAgICB0aGlzLmNhcGFiaWxpdGllcy5sb2dnaW5nUHJlZnMgPSBfLmNsb25lRGVlcChnZXRDYXBWYWx1ZShjYXBzLCAnbG9nZ2luZ1ByZWZzJywge30pKTtcbiAgICBpZiAoXy5pc0VtcHR5KHRoaXMuY2FwYWJpbGl0aWVzLmxvZ2dpbmdQcmVmcy5icm93c2VyKSkge1xuICAgICAgdGhpcy5jYXBhYmlsaXRpZXMubG9nZ2luZ1ByZWZzLmJyb3dzZXIgPSAnQUxMJztcbiAgICB9XG5cbiAgICBpZiAoZW1pdFN0YXJ0aW5nU3RhdGUpIHtcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX1NUQVJUSU5HKTtcbiAgICB9XG5cbiAgICBjb25zdCBhcmdzID0gWyctLXVybC1iYXNlPXdkL2h1YicsIGAtLXBvcnQ9JHt0aGlzLnByb3h5UG9ydH1gXTtcbiAgICBpZiAodGhpcy5hZGIgJiYgdGhpcy5hZGIuYWRiUG9ydCkge1xuICAgICAgYXJncy5wdXNoKGAtLWFkYi1wb3J0PSR7dGhpcy5hZGIuYWRiUG9ydH1gKTtcbiAgICB9XG4gICAgaWYgKF8uaXNBcnJheSh0aGlzLmNtZEFyZ3MpKSB7XG4gICAgICBhcmdzLnB1c2goLi4udGhpcy5jbWRBcmdzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9nUGF0aCkge1xuICAgICAgYXJncy5wdXNoKGAtLWxvZy1wYXRoPSR7dGhpcy5sb2dQYXRofWApO1xuICAgIH1cbiAgICBpZiAodGhpcy5kaXNhYmxlQnVpbGRDaGVjaykge1xuICAgICAgYXJncy5wdXNoKCctLWRpc2FibGUtYnVpbGQtY2hlY2snKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKCctLXZlcmJvc2UnKTtcbiAgICAvLyB3aGF0IGFyZSB0aGUgcHJvY2VzcyBzdGRvdXQvc3RkZXJyIGNvbmRpdGlvbnMgd2hlcmVpbiB3ZSBrbm93IHRoYXRcbiAgICAvLyB0aGUgcHJvY2VzcyBoYXMgc3RhcnRlZCB0byBvdXIgc2F0aXNmYWN0aW9uP1xuICAgIGNvbnN0IHN0YXJ0RGV0ZWN0b3IgPSAoc3Rkb3V0KSA9PiBzdGRvdXQuc3RhcnRzV2l0aCgnU3RhcnRpbmcgJyk7XG5cbiAgICBsZXQgcHJvY2Vzc0lzQWxpdmUgPSBmYWxzZTtcbiAgICBsZXQgd2Vidmlld1ZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdENocm9tZWRyaXZlclBhdGgoKTtcbiAgICAgIGF3YWl0IHRoaXMua2lsbEFsbCgpO1xuXG4gICAgICAvLyBzZXQgdXAgb3VyIHN1YnByb2Nlc3Mgb2JqZWN0XG4gICAgICB0aGlzLnByb2MgPSBuZXcgU3ViUHJvY2Vzcyh0aGlzLmNocm9tZWRyaXZlciwgYXJncyk7XG4gICAgICBwcm9jZXNzSXNBbGl2ZSA9IHRydWU7XG5cbiAgICAgIC8vIGhhbmRsZSBsb2cgb3V0cHV0XG4gICAgICB0aGlzLnByb2Mub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgICAvLyBpZiB0aGUgY2Qgb3V0cHV0IGlzIG5vdCBwcmludGVkLCBmaW5kIHRoZSBjaHJvbWUgdmVyc2lvbiBhbmQgcHJpbnRcbiAgICAgICAgLy8gd2lsbCBnZXQgYSByZXNwb25zZSBsaWtlXG4gICAgICAgIC8vICAgRGV2VG9vbHMgcmVzcG9uc2U6IHtcbiAgICAgICAgLy8gICAgICBcIkFuZHJvaWQtUGFja2FnZVwiOiBcImlvLmFwcGl1bS5zYW1wbGVhcHBcIixcbiAgICAgICAgLy8gICAgICBcIkJyb3dzZXJcIjogXCJDaHJvbWUvNTUuMC4yODgzLjkxXCIsXG4gICAgICAgIC8vICAgICAgXCJQcm90b2NvbC1WZXJzaW9uXCI6IFwiMS4yXCIsXG4gICAgICAgIC8vICAgICAgXCJVc2VyLUFnZW50XCI6IFwiLi4uXCIsXG4gICAgICAgIC8vICAgICAgXCJXZWJLaXQtVmVyc2lvblwiOiBcIjUzNy4zNlwiXG4gICAgICAgIC8vICAgfVxuICAgICAgICBjb25zdCBvdXQgPSBzdGRvdXQgKyBzdGRlcnI7XG4gICAgICAgIGxldCBtYXRjaCA9IC9cIkJyb3dzZXJcIjogXCIoLiopXCIvLmV4ZWMob3V0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgd2Vidmlld1ZlcnNpb24gPSBtYXRjaFsxXTtcbiAgICAgICAgICBsb2cuZGVidWcoYFdlYnZpZXcgdmVyc2lvbjogJyR7d2Vidmlld1ZlcnNpb259J2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWxzbyBwcmludCBjaHJvbWVkcml2ZXIgdmVyc2lvbiB0byBsb2dzXG4gICAgICAgIC8vIHdpbGwgb3V0cHV0IHNvbWV0aGluZyBsaWtlXG4gICAgICAgIC8vICBTdGFydGluZyBDaHJvbWVEcml2ZXIgMi4zMy41MDYxMDYgKDhhMDZjMzljNDU4MmZiZmJhYjY5NjZkYmIxYzM4YTkxNzNiZmIxYTIpIG9uIHBvcnQgOTUxNVxuICAgICAgICBtYXRjaCA9IC9TdGFydGluZyBDaHJvbWVEcml2ZXIgKFsuXFxkXSspLy5leGVjKG91dCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGxvZy5kZWJ1ZyhgQ2hyb21lZHJpdmVyIHZlcnNpb246ICcke21hdGNoWzFdfSdgKTtcbiAgICAgICAgICB0aGlzLnN5bmNQcm90b2NvbChtYXRjaFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnaXZlIHRoZSBvdXRwdXQgaWYgaXQgaXMgcmVxdWVzdGVkXG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICBmb3IgKGxldCBsaW5lIG9mIChzdGRvdXQgfHwgJycpLnRyaW0oKS5zcGxpdCgnXFxuJykpIHtcbiAgICAgICAgICAgIGlmICghbGluZS50cmltKCkubGVuZ3RoKSBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjdXJseVxuICAgICAgICAgICAgbG9nLmRlYnVnKGBbU1RET1VUXSAke2xpbmV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGxpbmUgb2YgKHN0ZGVyciB8fCAnJykudHJpbSgpLnNwbGl0KCdcXG4nKSkge1xuICAgICAgICAgICAgaWYgKCFsaW5lLnRyaW0oKS5sZW5ndGgpIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG4gICAgICAgICAgICBsb2cuZXJyb3IoYFtTVERFUlJdICR7bGluZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBoYW5kbGUgb3V0LW9mLWJvdW5kIGV4aXQgYnkgc2ltcGx5IGVtaXR0aW5nIGEgc3RvcHBlZCBzdGF0ZVxuICAgICAgdGhpcy5wcm9jLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICBwcm9jZXNzSXNBbGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IENocm9tZWRyaXZlci5TVEFURV9TVE9QUElORyAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gQ2hyb21lZHJpdmVyLlNUQVRFX1JFU1RBUlRJTkcpIHtcbiAgICAgICAgICBsZXQgbXNnID0gYENocm9tZWRyaXZlciBleGl0ZWQgdW5leHBlY3RlZGx5IHdpdGggY29kZSAke2NvZGV9LCBgICtcbiAgICAgICAgICAgICAgICAgICAgYHNpZ25hbCAke3NpZ25hbH1gO1xuICAgICAgICAgIGxvZy5lcnJvcihtc2cpO1xuICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxvZy5pbmZvKGBTcGF3bmluZyBjaHJvbWVkcml2ZXIgd2l0aDogJHt0aGlzLmNocm9tZWRyaXZlcn0gYCArXG4gICAgICAgICAgICAgICBgJHthcmdzLmpvaW4oJyAnKX1gKTtcbiAgICAgIC8vIHN0YXJ0IHN1YnByb2MgYW5kIHdhaXQgZm9yIHN0YXJ0RGV0ZWN0b3JcbiAgICAgIGF3YWl0IHRoaXMucHJvYy5zdGFydChzdGFydERldGVjdG9yKTtcbiAgICAgIGF3YWl0IHRoaXMud2FpdEZvck9ubGluZSgpO1xuICAgICAgYXdhaXQgdGhpcy5zdGFydFNlc3Npb24oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cuZGVidWcoZSk7XG4gICAgICB0aGlzLmVtaXQoQ2hyb21lZHJpdmVyLkVWRU5UX0VSUk9SLCBlKTtcbiAgICAgIC8vIGp1c3QgYmVjYXVzZSB3ZSBoYWQgYW4gZXJyb3IgZG9lc24ndCBtZWFuIHRoZSBjaHJvbWVkcml2ZXIgcHJvY2Vzc1xuICAgICAgLy8gZmluaXNoZWQ7IHdlIHNob3VsZCBjbGVhbiB1cCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChwcm9jZXNzSXNBbGl2ZSkge1xuICAgICAgICBhd2FpdCB0aGlzLnByb2Muc3RvcCgpO1xuICAgICAgfVxuXG4gICAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgICAgLy8gb2Z0ZW4gdGhlIHVzZXIncyBDaHJvbWUgdmVyc2lvbiBpcyB0b28gbG93IGZvciB0aGUgdmVyc2lvbiBvZiBDaHJvbWVkcml2ZXJcbiAgICAgIGlmIChlLm1lc3NhZ2UuaW5jbHVkZXMoJ0Nocm9tZSB2ZXJzaW9uIG11c3QgYmUnKSkge1xuICAgICAgICBtZXNzYWdlICs9ICdVbmFibGUgdG8gYXV0b21hdGUgQ2hyb21lIHZlcnNpb24gYmVjYXVzZSBpdCBpcyB0b28gb2xkIGZvciB0aGlzIHZlcnNpb24gb2YgQ2hyb21lZHJpdmVyLlxcbic7XG4gICAgICAgIGlmICh3ZWJ2aWV3VmVyc2lvbikge1xuICAgICAgICAgIG1lc3NhZ2UgKz0gYENocm9tZSB2ZXJzaW9uIG9uIHRoZSBkZXZpY2U6ICR7d2Vidmlld1ZlcnNpb259XFxuYDtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlICs9IGBWaXNpdCAnJHtDSFJPTUVEUklWRVJfVFVUT1JJQUx9JyB0byB0cm91Ymxlc2hvb3QgdGhlIHByb2JsZW0uXFxuYDtcbiAgICAgIH1cblxuICAgICAgbWVzc2FnZSArPSBlLm1lc3NhZ2U7XG4gICAgICBsb2cuZXJyb3JBbmRUaHJvdyhtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBzZXNzaW9uSWQgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBDaHJvbWVkcml2ZXIuU1RBVEVfT05MSU5FKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5qd3Byb3h5LnNlc3Npb25JZDtcbiAgfVxuXG4gIGFzeW5jIHJlc3RhcnQgKCkge1xuICAgIGxvZy5pbmZvKCdSZXN0YXJ0aW5nIGNocm9tZWRyaXZlcicpO1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBDaHJvbWVkcml2ZXIuU1RBVEVfT05MSU5FKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZXN0YXJ0IHdoZW4gd2UncmUgbm90IG9ubGluZVwiKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VTdGF0ZShDaHJvbWVkcml2ZXIuU1RBVEVfUkVTVEFSVElORyk7XG4gICAgYXdhaXQgdGhpcy5zdG9wKGZhbHNlKTtcbiAgICBhd2FpdCB0aGlzLnN0YXJ0KHRoaXMuY2FwYWJpbGl0aWVzLCBmYWxzZSk7XG4gIH1cblxuICBhc3luYyB3YWl0Rm9yT25saW5lICgpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IENEIGhhc24ndCBjcmFzaGVkXG4gICAgbGV0IGNocm9tZWRyaXZlclN0b3BwZWQgPSBmYWxzZTtcbiAgICBhd2FpdCByZXRyeUludGVydmFsKDIwLCAyMDAsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBFRCkge1xuICAgICAgICAvLyB3ZSBhcmUgZWl0aGVyIHN0b3BwZWQgb3Igc3RvcHBpbmcsIHNvIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICAgIGNocm9tZWRyaXZlclN0b3BwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmdldFN0YXR1cygpO1xuICAgIH0pO1xuICAgIGlmIChjaHJvbWVkcml2ZXJTdG9wcGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nocm9tZURyaXZlciBjcmFzaGVkIGR1cmluZyBzdGFydHVwLicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFN0YXR1cyAoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKCcvc3RhdHVzJywgJ0dFVCcpO1xuICB9XG5cbiAgYXN5bmMgc3RhcnRTZXNzaW9uICgpIHtcbiAgICBjb25zdCBzZXNzaW9uQ2FwcyA9IHRoaXMuZGVzaXJlZFByb3RvY29sID09PSBQUk9UT0NPTFMuVzNDXG4gICAgICA/IHtjYXBhYmlsaXRpZXM6IHthbHdheXNNYXRjaDogdGhpcy5jYXBhYmlsaXRpZXN9fVxuICAgICAgOiB7ZGVzaXJlZENhcGFiaWxpdGllczogdGhpcy5jYXBhYmlsaXRpZXN9O1xuICAgIGxvZy5pbmZvKGBTdGFydGluZyAke3RoaXMuZGVzaXJlZFByb3RvY29sfSBDaHJvbWVkcml2ZXIgc2Vzc2lvbiB3aXRoIGNhcGFiaWxpdGllczogYCArXG4gICAgICBKU09OLnN0cmluZ2lmeShzZXNzaW9uQ2FwcywgbnVsbCwgMikpO1xuICAgIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKCcvc2Vzc2lvbicsICdQT1NUJywgc2Vzc2lvbkNhcHMpO1xuICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX09OTElORSk7XG4gIH1cblxuICBhc3luYyBzdG9wIChlbWl0U3RhdGVzID0gdHJ1ZSkge1xuICAgIGlmIChlbWl0U3RhdGVzKSB7XG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKENocm9tZWRyaXZlci5TVEFURV9TVE9QUElORyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnJywgJ0RFTEVURScpO1xuICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoJ1NJR1RFUk0nLCAyMDAwMCk7XG4gICAgICBpZiAoZW1pdFN0YXRlcykge1xuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKENocm9tZWRyaXZlci5TVEFURV9TVE9QUEVEKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cuZXJyb3IoZSk7XG4gICAgfVxuICB9XG5cbiAgY2hhbmdlU3RhdGUgKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIGxvZy5kZWJ1ZyhgQ2hhbmdlZCBzdGF0ZSB0byAnJHtzdGF0ZX0nYCk7XG4gICAgdGhpcy5lbWl0KENocm9tZWRyaXZlci5FVkVOVF9DSEFOR0VELCB7c3RhdGV9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRDb21tYW5kICh1cmwsIG1ldGhvZCwgYm9keSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCh1cmwsIG1ldGhvZCwgYm9keSk7XG4gIH1cblxuICBhc3luYyBwcm94eVJlcSAocmVxLCByZXMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5qd3Byb3h5LnByb3h5UmVxUmVzKHJlcSwgcmVzKTtcbiAgfVxuXG4gIGFzeW5jIGtpbGxBbGwgKCkge1xuICAgIGxldCBjbWQgPSBzeXN0ZW0uaXNXaW5kb3dzKClcbiAgICAgID8gYHdtaWMgcHJvY2VzcyB3aGVyZSBcImNvbW1hbmRsaW5lIGxpa2UgJyVjaHJvbWVkcml2ZXIuZXhlJS0tcG9ydD0ke3RoaXMucHJveHlQb3J0fSUnXCIgZGVsZXRlYFxuICAgICAgOiBgcGtpbGwgLTE1IC1mIFwiJHt0aGlzLmNocm9tZWRyaXZlcn0uKi0tcG9ydD0ke3RoaXMucHJveHlQb3J0fVwiYDtcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYW55IG9sZCBjaHJvbWVkcml2ZXJzLCBydW5uaW5nOiAke2NtZH1gKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgKEIucHJvbWlzaWZ5KGNwLmV4ZWMpKShjbWQpO1xuICAgICAgbG9nLmRlYnVnKCdTdWNjZXNzZnVsbHkgY2xlYW5lZCB1cCBvbGQgY2hyb21lZHJpdmVycycpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oJ05vIG9sZCBjaHJvbWVkcml2ZXJzIHNlZW0gdG8gZXhpc3QnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZGIpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgQ2xlYW5pbmcgYW55IG9sZCBhZGIgZm9yd2FyZGVkIHBvcnQgc29ja2V0IGNvbm5lY3Rpb25zYCk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGxldCBjb25uIG9mIGF3YWl0IHRoaXMuYWRiLmdldEZvcndhcmRMaXN0KCkpIHtcbiAgICAgICAgICAvLyBjaHJvbWVkcml2ZXIgd2lsbCBhc2sgQURCIHRvIGZvcndhcmQgYSBwb3J0IGxpa2UgXCJkZXZpY2VJZCB0Y3A6cG9ydCBsb2NhbGFic3RyYWN0OndlYnZpZXdfZGV2dG9vbHNfcmVtb3RlX3BvcnRcIlxuICAgICAgICAgIGlmIChjb25uLmluZGV4T2YoJ3dlYnZpZXdfZGV2dG9vbHMnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSBjb25uLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGIucmVtb3ZlUG9ydEZvcndhcmQocGFyYW1zWzFdLnJlcGxhY2UoL1tcXERdKi8sICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLndhcm4oYFVuYWJsZSB0byBjbGVhbiBmb3J3YXJkZWQgcG9ydHMuIEVycm9yOiAnJHtlcnIubWVzc2FnZX0nLiBDb250aW51aW5nLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhc1dvcmtpbmdXZWJ2aWV3ICgpIHtcbiAgICAvLyBzb21ldGltZXMgY2hyb21lZHJpdmVyIHN0b3BzIGF1dG9tYXRpbmcgd2Vidmlld3MuIHRoaXMgbWV0aG9kIHJ1bnMgYVxuICAgIC8vIHNpbXBsZSBjb21tYW5kIHRvIGRldGVybWluZSBvdXIgc3RhdGUsIGFuZCByZXNwb25kcyBhY2NvcmRpbmdseVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnL3VybCcsICdHRVQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuQ2hyb21lZHJpdmVyLkVWRU5UX0VSUk9SID0gJ2Nocm9tZWRyaXZlcl9lcnJvcic7XG5DaHJvbWVkcml2ZXIuRVZFTlRfQ0hBTkdFRCA9ICdzdGF0ZUNoYW5nZWQnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQgPSAnc3RvcHBlZCc7XG5DaHJvbWVkcml2ZXIuU1RBVEVfU1RBUlRJTkcgPSAnc3RhcnRpbmcnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX09OTElORSA9ICdvbmxpbmUnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQSU5HID0gJ3N0b3BwaW5nJztcbkNocm9tZWRyaXZlci5TVEFURV9SRVNUQVJUSU5HID0gJ3Jlc3RhcnRpbmcnO1xuXG5leHBvcnQgeyBDaHJvbWVkcml2ZXIgfTtcbmV4cG9ydCBkZWZhdWx0IENocm9tZWRyaXZlcjtcbiJdLCJmaWxlIjoibGliL2Nocm9tZWRyaXZlci5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
